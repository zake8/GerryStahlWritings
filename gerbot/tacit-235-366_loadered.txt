Specifically PDF pages 235 to 366 
 
CHAPTER 9. INTERPRETIVE 
PERSPECTIVES FOR 
COLLABORATION  
The HERMES substrate includes a mechanism for organizing knowledge in a design 
environment into a network of perspectives . These perspectives provide support 
for design as a process of interpre tation and deliberation. They allow designers to 
interpret the design situation according to their individual and group interests. 
Perspectives provide a mechanism for creating, managing, and selectively 
activating different sets of design knowledge, such as critics, spatial relations, 
domain distinctions, palette items, and argumentation, so that alternative ideas can 
be deliberated and either adopted, rejected, or modified.  
The perspectives mechanism organizes all the design information in the knowledge 
base. A designer always works within a particular perspective. At any time, the 
designer can select a different perspective by name. When a given perspective is 
selected (“act ive”) then only information indexed for that perspective (or for a 
perspective inherited by that perspective) can be accessed, traversed, or displayed.  
A new perspective can be created by assigning a name to it and selecting existing 
perspectives for it to  inherit. Perspectives are connected in an inheritance network; 
a perspective can modify knowledge inherited from its parents or it can add new 
knowledge. Designers switch perspectives to examine a design from different 
viewpoints. Switching perspectives c hanges the currently effective definitions of 
critics, the terms used in these definitions, and other domain knowledge. For 
example, imagine that Archie was collaborating with Desi using the HERMES 
computer system. Then he could create archie’s habitat per spective  
and select desi’s habitat perspective  to inherit from. This would allow 
him to build upon and critique Desi’s work, without altering what is viewed by 
Desi in his perspective.  
The organization of information by perspectives encourages users to vie w 
knowledge in terms of structured, meaningful categories that they can create and 
modify. It provides an extensible structure of knowledge contexts that can 
      Tacit and Explicit U nderstanding in Computer Support                                       236 
  correspond to categories meaningful in the design domain. This eases the cognitive 
burden of manip ulating potentially large numbers of alternative versions of critics, 
rationale, graphics, language expression definitions, and other design knowledge.  
The perspectives mechanism allows items of knowledge to be bundled in various 
ways, which can overlap or thogonally or inter -connect. Common types of 
perspectives are:  
* personal and group viewpoints of individual designers and teams  
* topical groupings by content traditions (e.g., kitchen design)  
* technical aspects by specialties (e.g., plumbing)  
* historical versions (e.g., Archie’s Monday morning habitat design)  
For instance, archie’s habitat perspective  might include 
considerations specific to Archie’s design, as well as incorporating many ideas 
from Desi’s. If Desi and Archie are part of a larger team, t hen the team’s 
perspective could display concepts and rationale from all its members, or it could 
select from and modify the knowledge inherited from multiple sources. Archie 
would also want to inherit knowledge from lunar habitat design traditions and 
related technical specialties. Then, as his design evolved, Archie could define 
perspectives for archiving versions of his work.  
Lunar habitat design takes advantage of information from many technical 
disciplines and domain traditions: kitchen and bathroom de sign, low-gravity and 
vacuum considerations, electrical and lighting expertise, submarine and Antarctic 
isolation experiences. It can borrow selectively from both space station and Mars 
habitat prior designs. Each of these bodies of knowledge can be define d within a 
network of domains and subdomains that inherit, share, and modify knowledge 
from each other. Perspectives can also be used to save networks of historical 
versions of developing designs. The HERMES perspectives mechanism is a 
general—but hypermed ia specific —implementation of contexts20 that can be used 
to supply a variety of functionality to a design environment.  
This chapter will present the HERMES perspectives mechanism in three sections. 
First, Section 9.1 offers a scenario to show how a design team using HERMES might 
approach the task documented in the protocol analysis of Section 3.2, 
 
20 The terms perspective  and context will be used interchangeably in this Cha pter. 
Technically, the functionality of perspectives is implemented by defining 
contexts. As M. Gross suggested, perspectives are similar to the notion of 
“binding contexts” in programming languages: a definition is bound within the 
perspective in which it  was created.  
      Tacit and Explicit U nderstanding in Computer Support                                       237 
  “Perspectives on Privacy.” Second, Section 9.2 describes the techniques used to 
implement the perspectives mechanism in HERMES. This will detail the 
hypermedia character of the implementation. Third, Section 9.3 discusses how the 
perspectives mechanism can provide computer support for cooperative work. This 
will include examples of interface features for displaying, browsing, and sharing 
knowledge in multiple perspectives representing different people, interests, or 
domains.  
9.1. A Scenario of Cooperation  
The work of lunar habitat designers was studied in order to l earn about the work 
process of innovative cooperative design in a complex domain. Lunar habitat 
design seems to call for computer support because of the volume of technical 
information and governmental requirements, as well as because of the other -
worldly setting in which the designers’ tacit skills may be unreliable. It seemed 
wise to explore how lunar habitat designers work now without substantial 
computer support in order to envision new ways to support the old goals and to 
imagine how computer support w ould transform the tasks involved.21  
The episode transcribed in Chapter 3 showed an important turning point in a design 
process: the application of the concept of privacy to the task at hand. The tacit 
notion of privacy was eventually operationalized with  the idea of defining a 
privacy gradient, according to which public and private areas of a habitat are 
distributed based on their privacy ratings. The concept of privacy then provided a 
paradigmatic example for investigating the design rationale issue -base provided to 
lunar habitat designers by NASA: the Manned Systems Integration Standards 
(NASA, 1989a). Here it was seen that this important concept of privacy had largely 
eluded NASA’s extensive efforts to provide propositional rules for the design of 
space-based habitation. Although privacy was acknowledged to be an important 
issue, NASA failed to provide support for designers to take privacy into account.  
The present section will build on the discussion in the transcript and the critic 
definitions to show how HERMES can respond to the challenge of providing 
computer support for considerations of privacy. A scenario will show how lunar 
habitat designers could use the HERMES system to define a powerful set of privacy 
 
21 This “dialectic of tradition and transcendence” in work -oriented design of 
computer support systems is a central theme of Ehn (1988). The transformation 
of tasks as a result of computer support is also emphasized by, for instance, 
Hutchins (1990) and Norman (1993).  
      Tacit and Explicit U nderstanding in Computer Support                                       238 
  critics using the hypermedia links, perspe ctives, and language of HERMES. The 
detailed explanation of how the critics are evaluated by the system will be saved 
for Chapter 10.  
Desi’s perspective . Suppose that instead of sitting down together with pencil and 
paper, Desi and Archie had been part of a team that worked in a design 
environment built on the HERMES substrate. Desi, Archie, and two other team 
members (Phyllis and Sophia) are asked to design a lunar habitat for four 
astronauts to live in for 45 days. They decide to take turns working on the  design 
in HERMES, starting with Desi.  
Desi begins creating a perspective for his new work, which he names desi’s 
habitat perspective . He defines this perspective to include (inherit) the 
information collected in a number of specialties and domains that he  considers 
relevant to the design task. Then he selects two other lunar habitat perspectives and 
copies individual items of graphics and design rationale out of them for the lunar 
habitat shell, bunk -bed crew compartments, and a wardroom (dining and meetin g 
room) arrangement. He inserts these into design rationale and graphics in his 
perspective. Then he adds some rectangles to represent the bathroom and galley 
(kitchen). The resulting layout is shown in Figure 9 -1 (reproduced from Figure 3 -
2 of Section 3.2 ).  
Figure 9-1. Desi’s lunar habitat design.  
An initial sketch has been proposed for the design team to work on.  
 
The main functional areas of the habitat have been laid out in this sketch. This is 
an initial design concept. Because other team members will be reviewing this 
design and wondering why things are arranged the way they are, Desi adds some 

      Tacit and Explicit U nderstanding in Computer Support                                       239 
  design rationale, arguing that the bathroom and galley have all been placed 
together in a “wet wall” con figuration to minimize plumbing arrangements. Desi 
feels his design provides a good start for the team and he goes off to work on other 
projects. 
Archie’s perspective . Archie is interested to see what Desi has designed and to 
critique it from his own viewp oint. However, he does not want to destroy Desi’s 
version. So Archie defines archie’s habitat perspective  as a new 
perspective and lists desi’s habitat perspective  as its inherited 
perspective. This means that Archie will start off with everything that is in Desi’s 
perspective, but as he makes changes to it the changes will only be in effect within 
Archie’s perspective and not within Desi’s. The inheritance is active in the sense 
that if Desi subsequently modifies something in his perspective that Archie ha s not 
changed in his then the modification will show up in Archie’s perspective as well 
(unlike if Archie had simply made his own copy of Desi’s design at some given 
time).  
Archie also inherits a number of additional perspectives with useful technical 
information. The hierarchy of perspectives incorporated in Archie’s perspective —
including those he inherits via Desi’s perspective —are pictured in Figure 9 -2. 
 
 

      Tacit and Explicit U nderstanding in Computer Support                                       240 
  Figure 9-2. The hierarchy of perspectives inherited by Archie.  
Note that Archie has access via Desi’s perspective to information in the lunar, 
space-based, habitats, noise, vibration, and dust perspectives, as well as 
additional information related to housing and galleys.  
Archie is concerned with spatial adjacencies. He likes the way the crew 
compartments have been separated from the rest of the habitat to provide relief 
from the daily activity. However, he dislikes the acoustic proximity of the toilet 
(which flushes loudly) to the beds. Even worse, he finds the opening of the 
bathroom into the eatin g and gathering area potentially offensive. Archie is unsure 
of how to handle the bathroom, so he switches to a perspective that he has not 
inherited, the perspective for residential (terrestrial) bathrooms and browses the 
issue-base section on the design and placement of bathrooms. This perspective 
inherits from several other cultural and domain perspectives, including European 
perspectives. Here he finds the idea that showers and toilets have rather different 
location and adjacency considerations in the E uropean tradition.  
Applying these ideas in his mind to how he projects life in the habitat, Archie 
concludes that the shower should be near the sleep areas, but the toilet should be 
near the other end of the habitat, by the entrance. Moving the shower giv es him the 
idea of elaborating the separation of the sleeping and working areas by forming a 
dressing area incorporating personal stowage. He redesigns the galley based on 
other ideas he finds and feels he has reached a stopping point. (See Figure 9 -3.) He 
copies the rationale from the bathroom perspective concerning the separate 
location of the shower and toilet, revising the rationale to apply to the lunar habitat.  
 
 
Figure 9-3. Archie’s lunar habitat design.  
The toilet and shower functions have been sep arated using the European 
perspective on bathroom design.  

      Tacit and Explicit U nderstanding in Computer Support                                       241 
   
Archie revises the design rationale for the habitat. Within his perspective, he can 
modify or add to (annotate or author) anything in the issue bases he has inherited 
from Desi or from the other do mains. He does this in preparation for the up -coming 
team meeting. Before the meeting, the team members each review Archie’s design 
and its rationale by displaying it in HERMES. First, they discuss the over -all design. 
They like the creation of the dressin g area between the shower and the personal 
stowage but  argue that it blocks traffic flow. A consensus is reached when Phyllis 
drags the dressing area to the other side of the crew compartments in the HERMES 
construction area.  
As a group they deliberate ab out the issues in Archie’s rationale section and agree 
that habitation issues must be the primary focus of their designing on this project. 
In particular, privacy is a key concept. In order to make the notion of privacy 
operational for evaluation by interp retive critics, they decide to label the parts of 
the habitat with privacy ratings. They agree on the following scale with values 
from 1 to 9:  
very public:   1 
quite public:   2 
public:   3 
somewhat public:  4 
neutral:    5 
somewhat private:  6 
private:    7 
quite private:   8 
very private:   9 
They define a link type, privacy rating , and use this type to link each area 
of the habitat to a node with one of the above numeric values (or their equivalent 
label). This process is facilitated by the HERMES interface: cli cking on an area like 
the shower in the habitat brings up the same Navigating the Hypertext dialog seen 
in Figure 8 -3 (in Section 8.3). Selecting the Author or Annotate  option allows them 
to define a new numeric node with the value 8 or quite private  and to 
connect it to the shower with a privacy rating  link automatically. Figure 9 -
4 below shows the lunar habitat design the team has come up with, labeled with 
the agreed upon privacy ratings . 
At the end of the meeting, Sophia and Phyllis agree to develop a s uite of privacy 
critics that can be used for this and future lunar habitat design assignments.  
Sophia’s perspective . Sophia sets up her perspective to inherit all of Archie’s 
work (and, indirectly, Desi’s). Now Sophia must define the terminology to be used 
in her critics. She is interested in determining problem areas in which private areas 
      Tacit and Explicit U nderstanding in Computer Support                                       242 
  are too near to public areas . By “too near ,” Sophia decides she means less than five 
feet. So she defines a “Measure” in the HERMES language named too near  as: 
closest distance is less than 5 feet  
 
Figure 9-4. Archie’s lunar habitat with its privacy ratings.  
 
Then, she defines public and private areas in terms of the ends of the privacy scale:  
public area: parts that have privacy ratings that are less 
than somewhat public  
private areas: parts that have privacy ratings that are 
more than somewhat private  
Next, she defines the problem areas she is concerned with using these terms:  
problem areas: private areas with public areas of that 
(last subject) that are too near those items  
Then, Sophia defines a message for her critic to display if no problem areas are 
found: 
privacy message: “Public and private areas are separated.”  
Finally, she can define her privacy check  critic: 
name with either name of problem areas or privacy message  
This critic, privacy check , is a predicate that can be applied to any node or 
list of nodes in the database. When Sophia applies it to her lunar habitat design, it 

      Tacit and Explicit U nderstanding in Computer Support                                       243 
  lists the name of the design and then lists all the problem areas  in the habitat 
by their names; if no problem areas  are found, it displays the privacy 
message . Figure 9 -5 shows t he output from applying privacy check  to the 
design of archie’s lunar habitat  shown in Figure 9 -4: 
CRITIQUE OF DESIGN
Critic
archie's lunar habitat
shower
bunk 1
galley
toilet
galley
science work area
bunk 2
wardroom tableprivacy check of archie's
lunar habitat
 
Figure 9-5. Output from the privacy check critic.  
 
Note that all private areas  are listed by name. Under each of them are the 
public areas  that are too near  to them. The way this critic is defined it 
supports the designer’s review of the information. Sophia gets a complete listing 
of private areas from which she can check just what problematic 
adjacencies each has so she can also make sure the critic is doing exactly the 
computation she wants it to.  
Debugging of critics is an important process, particularly since much of the 
computation is implicit in the language expressions. The privacy check  is a 
fairly complex critic that Sophia has developed and debugged gradually. Once she 
is sure it is working, she can use it as a basis for more complicated evaluations. 
For instance, the display of the lunar habitat design in HERMES does not ac tually 
include the privacy ratings  that were shown in Figure 9 -4. So Sophia 
decides she wants to print these values out along with the listing of areas. To do 
this, she defines a new critic that prints out both the name and the privacy 
rating of each liste d area: 
privacy display: name and privacy ratings of problem areas  
The result of applying this critic to archie’s lunar habitat  is shown in 
Figure 9-6. (The names of the privacy ratings  are shown in bold.) 
      Tacit and Explicit U nderstanding in Computer Support                                       244 
  
CRITIQUE OF DESIGN
Critic
shower
bunk 1
galley
toilet
galley
.  .  .  .quite private
private
very public
very private
very publicprivacy display of archie's
lunar habitat 
Figure 9-6. Output from the privacy display critic.  
 
Now that Sophia has gotten her critics working the way she wants them to, she 
decides to make them general enough to apply to lists of objects. Then, as more 
habitats are developed in the HERMES database and are labeled  with privacy values, 
designers can use Sophia’s privacy critics to display catalogs of interesting 
habitats. This is illustrated in Figure 9 -7. This way Sophia can quickly find 
examples of problem areas in past habitat designs to help her deliberate about  when 
such adjacencies might in fact be acceptable.  
 
CRITIQUE OF DESIGN
Critic
archie's lunar habitat
shower
bunk 1
galley
toilet
galley
science work areasandra's lunar habitat
Public and private areas are separated.
Public and private areas are separated.sandra's revised lunar habitatprivacy check of lunar habitats
 
      Tacit and Explicit U nderstanding in Computer Support                                       245 
  Figure 9-7. The privacy check critic applied to a list of all lunar habitats  
 
Phyllis’ perspective . Phyllis is a super -user of the HERMES language. To test its 
power, she tries to define a critic that involves a complex series of computations. 
By using an advanced feature of the language (explained in Section 10.3 below), 
she succeeds. Phyllis recalls previous discussions between Desi and A rchie (from 
Chapter 3) that proposed the concept of a privacy gradient. That meant that the 
arrangement of the habitat should gradually change from private areas to public 
areas. To operationalize this notion, Phyllis introduces a test to see if any two ar eas 
of the habitat that are near each other differ in their privacy values by more than 
two.  
Phyllis defines the following set of definitions to compute problem parts  in 
her sense:  
are incompatible: have privacy ratings that are more than 
privacy ratings of that (last subject) + 2 or are less 
than privacy ratings of that (last subject) -2 
too near: closest distance is less than 3 feet  
other parts: parts of inverse parts that do not equal that 
(last subject)  
problem parts: name and privacy ratings of other  parts that 
are too near that (last subject) and that are 
incompatible  
These definitions illustrate the limits of the HERMES language, calling upon 
advanced features of the language that only experienced users of HERMES would 
feel comfortable using to crea te new expressions. The wording of some of Phyllis’ 
expressions are no longer intuitive because their computations refer outside of the 
expressions used to define them. In fact, the wording in such cases is designed to 
interrupt tacit understanding and to stimulate reflection on the explicit 
computational relations. Fortunately, this complexity is generally encapsulated in 
the names of the expressions so future users need not always be concerned with it.  
Note that Phyllis has defined a measure with the sam e name (too near ) as one 
of Sophia’s, but with a different value. This is not a problem since they are working 
in independent perspectives (even though they inherit much of the same 
information from other perspectives.)  
      Tacit and Explicit U nderstanding in Computer Support                                       246 
  
CRITIQUE OF DESIGN
Critic
shower
bunk 1
galley
toilet
galley
science work areaquite private
private
very public
very private
very publicsandra's lunar habitat
The parts of this are arranged along a privacy gradient.
The parts of this are arranged along a privacy gradient.sandra's revised lunar habitat
archie's lunar habitatprivacy gradient catalog
publicgalley 
Figure 9-8. Output from the privacy gradient catalog expression.  
 
To complete the privacy gradient critique , Phyllis defines a format for 
listing problem parts, and she specifies a message for the case in which no problem 
parts are found in a habitat:  
privacy gradient listing: name and privacy ratings with 
problem parts  
privacy gradient message: “The parts of this design are 
arranged along a privacy gradient.”  
privacy gradient critique: either privacy gradient listing 
of parts or privacy gradient message  
Like Sophia, Phyllis wants to apply her critique to all habitats  in the database. 
Note that in the following definition for this procedure Phyllis first filters the list 
of habitats  to just those for which privacy ratings  have been defined. 
This produces a l ist of habitats for which issues of designing for privacy are most 
likely to have been thought through and to provide relevant ideas and rationale.  
      Tacit and Explicit U nderstanding in Computer Support                                       247 
  For these habitats, it is indicated which meet the criteria of following a privacy 
gradient and where the p roblem areas are in those that do not. A sample result is 
shown in Figure 9 -8. Here is Phyllis’ final critic rule or display expression, 
privacy gradient catalog :  
name with privacy gradient critique of habitats that have 
parts that have privacy ratings  
The team perspective . When the team comes back together, they are enthusiastic 
about the power of the privacy critics to automate some complex analysis of 
habitats for them. Desi says, “I never tried to define anything in the HERMES 
language; I just make lit tle adjustments to the display definitions and critics that I 
find already in the system. They usually meet my needs. But these new critics do 
things I could never do before. And I think I understand them well enough to use 
them and maybe even tweak them.”  “Yeah,” chimed in Archie, “I never used the 
advanced syntax options for dealing with graphics and distances. Maybe I can learn 
how to do that by playing around with these privacy critics. Can you put them all 
in a perspective where we can experiment with them?”  
Sophia was happy to oblige: “Sure. The thing we need to be careful about is the 
definition of too near , because Phyllis and I disagree on that. Let’s make the 
default for that 5 feet, okay?” She created a perspective called lunar habitat 
design tea m that anyone could inherit from to experiment with the critics or 
to pursue their design work further. She had the new perspective inherit from both 
the sophia perspective  and the phyllis perspective , making sure 
she listed the sophia perspective  first so that its definitions would override 
in case of conflicts, as with the definition of the expression too near . 
Figure 9-9 shows the dialog box for creating the new perspective. Figure 9 -10 
shows the new hierarchy of defined perspectives.  
 
      Tacit and Explicit U nderstanding in Computer Support                                       248 
   
Figure 9-9. Creating a new perspective.  
9.2. A Hypermedia Implementation of 
Perspectives  
This section discusses the implementation of the HERMES perspectives 
mechanism. The ten methods discussed below are used by the HERMES substrate 
internally. The user never needs to know how they work. Even people who build 
design environment components on top of the HERMES substrate do not need to be 
concerned with the details but  can simply call the methods. The purpose of this 
section is to describe some of the computation that takes place behind the scenes 
every time a designer retrieves, displays, navigates, modifies, c ritiques, or analyzes 
information in the system. It is an example of the active computation that supports 
the user’s tacit design work.  
As suggested in Chapter 7, the perspectives (or, equivalently, contexts) mechanism 
in HERMES is loosely based on the vir tual copying of networks approach proposed 
by Mittal, et al. (1986) and the general copy -on-write technique discussed by 
Fitzgerald and Rashid (1986). More particularly, it was proposed by McCall 
(1991/92) for application to hierarchical networks of domain  rationale in PHIDIAS. 
In HERMES, the perspectives mechanism has been expanded and generalized so 

      Tacit and Explicit U nderstanding in Computer Support                                       249 
  that all information (e.g., graphics and other media, as well as definitions of 
language expressions) is accessible relative to the perspectives.  
There are t wo parts to the perspectives mechanism. First, there is a hierarchy of 
defined perspectives that is maintained as a network of (context) nodes and 
(context) links. Second, every link in the hypermedia database contains lists 
specifying which perspectives m ay or may not be active for the link to be traversed. 
The question as to what perspective is the “active” one at any given time is 
answered by reference to a value maintained by the HERMES application.  
 
Figure 9-10. Hierarchy of perspectives inherited by the team. 
 
The hierarchy of perspectives is quite simple. It looks much like the nodes and 
links pictured in Figure 9 -10. When a new perspective is defined by a user through 
a dialog box like that in Figure 9 -9, a new context node is created. It is linked to 
the context nodes it inherits from by a simple context link. As discussed in Chapter 
8, context nodes and links are like regular nodes and links except that they have no 
node kinds or link types. Context nodes have just their names and their links to 
other contexts. Like any node in HERMES, they can be time -stamped and they can 
be linked to annotations or other attributes. This linking can be used for 

      Tacit and Explicit U nderstanding in Computer Support                                       250 
  documentation or to implement security systems that restrict movement from one 
perspective to another. H owever, in the normal HERMES system all information 
can be accessed by all users; it is organized in perspectives to support timely 
access. Traversal of the context hierarchy is similar to normal hypermedia 
traversal, but it has been optimized for efficien cy. 
Links in HERMES consist of multiple sublinks between a given pair of nodes. Each 
sublink maintains four items related to the perspectives mechanism: (1) the original 
context in which the link was created, (2) a list of added contexts in which the link 
can also be traversed, (3) a list of deleted contexts in which the link should not be 
traversed, and (4) a “switch” context to which the active perspective should be 
changed when the link is traversed. This information supports ten methods for the 
virtual copying of nodes, links, or hypermedia networks, as discussed in this 
section. 
When the system wants to traverse a link, it tests to see if any of the link’s sublinks 
can be traversed. The test proceeds as follows: (a) If the currently active 
perspective o r any of its inherited ancestors matches a context on the deleted list 
(3), then the sublink cannot be traversed. (b) If the currently active perspective or 
any of its inherited ancestors matches the original context (1) or a context on the 
added list (2),  then the sublink can be traversed. If there is a switch context (4), 
then when the link is traversed the active perspective must be changed to the 
switched context. The inherited ancestors are checked through a breadth -first 
recursive search with a check for cycles in the inheritance network. Conflicts from 
multiple inheritance have no consequence since there is no content to the context 
nodes, the first match halts the search, and alternative paths are equivalent.  
Recall from Chapter 8 that named nodes ar e separated from their contents. So, 
links connect pairs of named nodes and they also connect named nodes with their 
content. Because the contexts are checked during link traversal, they control both 
which named nodes are connected in the active perspectiv e and what contents go 
with a given named node in that perspective. This is why it is possible for a given 
named node (e.g., the language expression named “ too near ”) to have different 
contents (different definitions) in different perspectives.  
The follow ing suite of ten methods implement the creation, deletion, and 
modification of links, nodes, and contents relative to perspectives. They are 
defined as object methods for VCopy nodes (see Section 8.2). They provide the 
following functions:  
1. Copy the info rmation from one context (perspective) into another.  
2. Delete one node in a context that descends from another context.  
3. Modify one node in a context that descends from another context.  
      Tacit and Explicit U nderstanding in Computer Support                                       251 
  4. Delete one link in a context that descends from another context.  
5. Modify one link in a context that descends from another context.  
6. Physically copy one node from one context into another context.  
7. Virtually copy one node from one context into another context.  
8. Reuse a subnetwork from one context in another cont ext. 
9. Virtual copy a subnetwork from one context into another context.  
10. Lazy virtual copy a subnetwork from one context into another context.  
Method 1: copy an entire context . Given the foregoing apparatus, the ten virtual 
copying methods can be expla ined. The simplest is to just copy all the contents of 
one perspective into a new perspective. For instance, Archie wanted to make his 
own copy of everything that was visible in Desi’s perspective. This is done by 
defining the new perspective and having it  inherit from the old one. Then, when 
the system checks a link to a node or to a node’s contents when the new context is 
the active one, it will start by trying to match the new context and then will try to 
match its ancestors. The old context is its ances tor, so a match will be found when 
the new context is active if and only if it would have been found when the old 
context was active. Therefore, the same nodes and contents will be visible to 
Archie as to Desi. Of course, once Archie starts adding, modifyi ng, or deleting 
nodes or links in his perspective, sublinks will start being labeled with Archie’s 
new context and this will introduce changes between the two perspectives.  
This approach is called virtual copying  because the effect is to make it seem that  
all the information from one perspective has been copied into the other perspective. 
However, nothing has in fact been physically copied in the database. In fact, no 
nodes or links have been changed at all, except the addition of the new context 
node and its links in the perspectives inheritance hierarchy. Physical changes to 
the nodes and links only take place when there are changes made to the virtual 
copies. That is, if Archie deletes or modifies a node or link that was originally 
created by Desi, then changes must be made to ensure that the modifications or 
deletions show up in Archie’s perspective but not in Desi’s. On the other hand, if 
Desi changes something that has not been altered by Archie, then these changes 
should show up in both perspectives. Under many circumstances, his last point is 
an advantage of virtual copying over physical copies —in addition to the great 
savings of memory and time.  
The next four methods are for handling deletions or modifications to virtual copies 
in a descendant persp ective.  
Method 2: delete a node in a descendant context . To delete a node, simply add 
the name of the current perspective to the delete list of the sublink. For instance, 
      Tacit and Explicit U nderstanding in Computer Support                                       252 
  to delete in Archie’s perspective a named node or a content node that was virtual 
copied from Desi’s perspective, leave its original context (Desi’s) alone and add 
Archie’s perspective to the delete list of the sublink of the link leading to the node. 
Then when traversal of that link is attempted in Archie’s perspective, the delete 
list will prohibit the traversal, although it will still be permitted in Desi’s 
perspective.  
Method 3: modify a node in a descendant context . To modify a node, first create 
a physical copy of it in the new perspective and link it with a new link labeled with 
the current perspective as its original context. Then delete the old node in the 
perspective using method 2. Suppose Desi had defined too near as closest 
distance is less then 5 feet  and Archie modified it to  closest 
distance is less then 3 feet ; the result is shown in Figure 9 -11. 
 
Figure 9-11. The result of modifying the virtual copy of a node.  
  
Method 4: delete a link in a descendant c ontext. This is identical to method 2. 
To make it so that a link will not be traversed in the descendent context is to make 
the linked node effectively deleted in that context.  
Method 5: modify a link in a descendant context . This is similar to method 3, 
although no changes to nodes are made. Rather a new sublink of the original link 
is created. The original sublink and the new sublink are labeled as were the two 
links in method 3 (and Figure 9 -11). Now there are two routes through the link to 
the node. On e will be crossed in the ancestor context(s) the other in the descendent 
context.  
Recall that display attributes and spatial transforms are stored in the sublinks, so 
which sublink gets traversed can make a significant difference in how the node at 
the end of the link is displayed. For instance, the node could be the graphics for a 
brick in a wall. If the wall consists of thousands of identical bricks, it could be 
made up of thousands of virtual copies of the one graphic node, each reached by a 
different s ublink having different spatial transforms to locate that copy in the wall. 
Such efficient vector graphics is a major benefit of the virtual copying scheme, 
although it is not a central concern of this dissertation.  

      Tacit and Explicit U nderstanding in Computer Support                                       253 
  The remaining methods handle cases in wh ich one does not wish to copy an entire 
perspective, but rather just a single node of a linked network of nodes.  
Method 6: physical copy one node into another context . One can always simply 
make a physical copy of a node from one context to another. The ol d node is not 
changed. The link from the new copy of the named node to the new copy of its 
content is labeled with the new perspective. This option can be used in place of 
virtual copying in cases where one does not wish the copy to change if its original 
prototype is changed in its old perspective.  
Method 7: virtual copy one node into another context . This method uses the list 
of added contexts in the sublist. To copy a node from, say, Phyllis’ perspective to 
an independent perspective, like Sophia’s, sim ply add Sophia’s perspective to the 
add list of the link between the node and its content. (The perspective hierarchy in 
Figure 9-12 is assumed in this and the following methods.)  
 
Figure 9-12. An illustrative perspectives hierarchy.  
  
Method 8: reuse a subnetwork in another context . This method uses the switch 
context in the sublist. To virtual copy a network of nodes in, say, Phyllis’ 
perspective so they can be traversed in an independent perspective like Sophia’s, 
first create a new context and  have it inherit from Phyllis’ context. This context 
need not even have a name; since it is used internally, it can always be referenced 
directly by its internal object id. Although the number of such internally defined  
contexts may proliferate with extens ive virtual copying, they will never appear to 
the system users. Then create a link from where you want to enter this subnetwork 
in Sophia’s perspective to the first node you want to traverse to in Phyllis’ 
perspective. This link will have Sophia’s perspec tive as its original context. Define 
its switch context to be the new internal context as in Figure 9 -13. Then, what 
happens when you traverse this link from Sophia’s perspective is that your 
currently active perspective changes to the internal context. Si nce this context is a 
descendant of Phyllis’ perspective, you can now freely traverse the subnetwork.  

      Tacit and Explicit U nderstanding in Computer Support                                       254 
   
Figure 9-13. Switching contexts to traverse a subnetwork.  
The network of nodes on the left is visible in Sophia’s perspective; that on the 
right in Phyl lis.’ The link between them can be traversed in Sophia’s perspective, 
but it switches the active perspective to an internally defined descendent of 
Phyllis’ perspective so that the right -hand network will be visible.  
 
Method 9: virtual copy a subnetwork in to another context . This method is an 
extension of method 7 and an alternative to method 8. The disadvantage of this 
method is that it is more computationally intensive to set up. Whereas method 8 
involves just adding an internal context to the perspective s hierarchy and creating 
a single new link with the switch context, method 9 involves inserting the current 
context into the add list of a sublist in every link of the subnetwork. If the 
subnetwork has thousands of nodes linked together, this can be an exp ensive 
operation, involving many disk accesses.  
Method 10: lazy virtual copy a subnetwork into another context . This is a 
variation on method 9. Instead of traversing the entire subnetwork and inserting 
the current perspective into all the sublink add lis ts at once, only the link to the 
first node is treated. All links coming out of this node are then marked for future 
treatment. As each of these links is traversed in the future during normal 
operations, those links are treated and the links further down i n the subnetwork 
coming out of their nodes are then marked for future treatment. This spreads out 
the costs and delays them until they are unavoidable. A further advantage is that 
prior to virtual copying each of the nodes as they are encountered, the user  can be 
queried if the node should actually be included in the new perspective. This allows 
the user to browse through the network and selectively include just those nodes 
that are really desirable in the new perspective.  
Method 10 uses the procedural atta chment technique mentioned in Chapter 8. 
Every node in the system is capable of having an arbitrary procedure attached to 
it. The nodes to be treated in the future by method 10 are marked by having the 
lazy virtual copying procedure attached to them. Then when they are traversed, the 
procedure is executed,  and it treats them and their further links appropriately. This 
is a form of delayed recursion.  

      Tacit and Explicit U nderstanding in Computer Support                                       255 
  The ten methods reviewed here (along with the context hierarchy and the 
procedure for checking links during attempted traversal) suffice for implementing 
the HERMES perspectives mechanism. They provide an efficient means for 
organizing information in over -lapping categories, such as hierarchies of personal 
and group viewpoints, of technical aspects, and of domai n traditions. The virtual 
copying is also useful for efficient versioning schemes, CAD graphics, and 
information security systems. The following section will touch on some ways this 
mechanism can be used to support interpretation in collaborative design.  
9.3. Evolving Perspectives  
Supporting knowledge evolution . As knowledge in the database grows and 
changes, it must often be reorganized. The evolution of knowledge means that 
different designers are adding, deleting, and changing information in different 
perspectives. In a design environment without perspectives all the growth of 
knowledge would take place within a single, homogeneous knowledge base. When 
the organization of this knowledge became disorganized and contradictory it might 
be necessary for a res eeding process to take place. This could involve specialist 
programmers or knowledge engineers (that is, people other than the designers who 
normally use the system) to step in and impose order and consistency. They might 
extend some of the system function ality as well, but their main task would be to 
straighten out the organization of knowledge.  
In HERMES, the perspectives mechanism can be used by the designers themselves 
to do some of the reseeding process in an on -going way. They can also use the 
language to extend the functionality of the system, defining, for instance, new 
analytic computations.  
A paradigmatic task for supporting the evolution of perspectives and their 
knowledge is the merging of two unrelated perspectives. This was also identified 
as a critical task by the authors of the perspectives mechanism in the PIE system, 
reviewed in Chapter 7. In Section 9.1, above, the design team decided to merge the 
privacy critic work in phyllis’ perspective  with that in sophia’s 
perspective , creating a new  lunar habitat design team  perspective. 
This is an example of reorganizing evolved knowledge. The new perspective might 
also be designated the privacy perspective . The point is that multiple 
independent efforts had created new knowledge in separate perspec tives. Because 
the designers decided that this knowledge belonged together, they created a new 
category (perspective) for it and reorganized the knowledge accordingly.  
      Tacit and Explicit U nderstanding in Computer Support                                       256 
  Figure 9-14 shows the HERMES interface for doing this. It is similar to the 
schematic i n Figure 9 -9. Here, the new perspective is created by assigning it a 
name. Then existing perspectives are chosen from a pick list (either as a sorted list 
or a hierarchical tree) to specify what information should be inherited. The 
inheritance takes place using Method 1 described in Section 9.2. In the particular 
scenario of Section 9.1, there was a multiple inheritance conflict in the definition 
of the expression, too near . Such conflicts are resolved through a breadth -first 
search of the inheritance tree.  So the version of information in the most immediate 
ancestor perspective takes precedence. In case of two ancestors at the same level, 
the one named first in the dialog takes precedence. Note that this dialog allows one 
to review and modify the inheritanc e tree of existing perspectives as well as 
perspectives being newly created in the dialog.  
Once the new perspective is set up, designers can browse through the information 
visible in the perspective and modify it. Information can be added, deleted or 
modified using the methods described in Section 9.2. This process of adding, 
deleting, and modif ying applies to both named nodes and to their contents. It also 
applies to both individual nodes and to whole subnetworks of nodes. For instance, 
an issue in the design rationale could be wholly deleted or it could merely have its 
content changed in the ne w perspective. Furthermore, the networks of subissues, 
answers, and arguments underneath a given issue could be copied in from another 
perspective by one of several alternative methods already described in Section 9.2.  
 
      Tacit and Explicit U nderstanding in Computer Support                                       257 
   
Figure 9-14. Interface for merging existing information into a new perspective.  
 
Of particular interest in merging design rationale and other information from 
different perspectives is the fact that multiple opinions can be preserved or 
suppressed at will. Figure 9 -15 shows the same  segment of design rationale as 
viewed in three perspectives, which inherit from each other sequentially (right to 
left). Two kinds of changes have been made in the subsequent perspectives: 

      Tacit and Explicit U nderstanding in Computer Support                                       258 
  changes that overwrite the previous opinions and changes that add to the previous 
opinions. 
In each perspective, the same three issues are raised. For the answer to the second 
issue— “What should be the access to the bunks?” —the middle perspective has 
added an additional answer to the original one and the perspective on the left has 
added a third answer to those two answers. So in the final perspective, which 
inherits from the other two, the three competing answers are all visible. However, 
the answers to the third issue — “What should be the arrangement of the bunks?” —
replace each other. Here, the issue is answered differently in each perspective 
because the inherited answers were deleted or modified to the new answers. This 
shows how support for evolution of information can equally support the 
accumulation and deliberatio n of historical versions of information or the replacing 
and modification of information.  
 
Figure 9-15. Three perspectives on a segment of design rationale.  
 
Another important concern for the evolution of knowledge is the need to support 
the demotion and promotion of items of information from a given perspective to 

      Tacit and Explicit U nderstanding in Computer Support                                       259 
  one that is higher or lower in the perspective hierarchy. Assume that there is a 
hierarchy of domain traditions such as that on the right -hand side of Figure 9 -10. 
From most general to most spec ific there are the perspectives: habitats, space -
based habitats, and Mars or lunar habitats. Suppose that a particular network of 
design rationale had been formulated by a designer working in the space-based 
habitat perspective  at some point in the past. I n reviewing this 
information within the lunar habitat design team perspective the 
design team members use the language constructs discussed below to determine 
which context this rationale is defined in, and they decide as a group that the 
rationale is gene ral enough to be placed in the habitats perspective . 
Alternatively, they might decide that some other rationale is too specific to the 
moon and should be located in the lunar habitat perspective . By 
clicking on the top node of the subnetwork of rationale, they can bring up an 
interface dialog box (see Figure 9 -16) that suggests a number of options for 
reorganizing the location within the perspectives hierarchy of the node and/or the 
network of nodes connected to it. These options are implemented with the me thods 
described in Section 9.2.  
 
Figure 9-16. Interface for demoting or promoting a node or subnetwork of nodes.  

      Tacit and Explicit U nderstanding in Computer Support                                       260 
   
Browsing perspectives . The perspectives mechanism simplifies the task of 
locating information in the rich knowledge base of an evolving desig n environment 
by partitioning the knowledge into useful categories. However, it also adds to the 
complexity of finding information because the knowledge being sought may not 
be visible in the current perspective even though it exists in the system. It may not 
be obvious what perspective to look in. Support must be provided for searching 
the network of perspectives and for browsing the knowledge available in the 
different perspectives.  
 LHDE provides a simple browser with an indented outline representation of the 
hierarchy of perspectives or a sorted list of the perspectives names as part of the 
interface for perspectives selection and new perspective creation. This may be 
adequate for people who are only interested in a handful of perspectives whose 
names they recognize. It may also suffice as long as the hierarchy makes intuitive 
sense, perspectives have descriptive names, and knowledge is distributed among 
the perspectives in a clear and systematic manner. As the knowledge base evolves, 
extended by multipl e users, these conditions will likely not persist. Of course, users 
can switch to different perspectives and explore the information there with display 
queries and hypermedia navigation. Also, more sophisticated graphical browsers 
can be added to the syste m interface to better represent the network of perspectives.  
The HERMES language also offers a more flexible and expressive solution to the 
problem of browsing the perspectives hierarchy and the knowledge bases in the 
various perspectives. As discussed in the next chapter, the language syntax falls 
into three primary classes: DataLists, Associations, and Filters. Each of these 
classes supports the formulation of expressions providing information about 
perspectives or contexts. (a) One can produce DataLists of objects that are visible 
in some arbitrary context other than the current active perspective. (b) One can list 
context information associated with a given object in the database. (c) One can 
filter a list of contexts in terms of their inheritance relati ons to other contexts or in 
terms of what objects are visible within them. This provides a useful suite of 
language functions for browsing the perspectives and exploring how they partition 
knowledge. Examples of these functions will now be given.  
(a) The f irst function allows one to, in effect, switch perspectives within the 
evaluation of a language expression. For instance, if Phyllis wants to see what 
habitats are visible from Sophia’s perspective,  then she can request a display of the 
following DataList:  
habitats in sophia’s perspective  
      Tacit and Explicit U nderstanding in Computer Support                                       261 
  This produces the same effect as if she had first switched contexts and then 
evaluated the expression, habitats . The same function allows Phyllis to apply 
her privacy critic to the habitats in Sophia’s perspective rather t han in her own:  
privacy gradient catalog of habitats in sophia’s 
perspective  
By including this capability in the language, it can be used as part of a complex 
computation that may involve several context switches. Once defined, such a 
computation can be gi ven a name and subsequent users of the expression do not 
have to worry about doing all the switching or remember what nodes are in which 
contexts. 
(b) The second language function related to perspectives provides a special report 
on the context information  associated with an item or a list of items. For each item, 
it provides the original context that it was defined in, the list of all added contexts 
in which it also appears, the list of all deleted contexts in which it does not appear, 
and the optional swi tch context. (Only named —user-defined—contexts are listed, 
not internally defined ones.) This way, one can find all the perspectives in which 
a given item is visible. In the following example, the contexts  Association is 
applied to the result of a query:  
contexts of habitats in hermes_universal_context  
This example uses the function discussed in the previous paragraph to first switch 
to the special perspective, hermes_universal_context . This special 
perspective allows all knowledge in the database to be vis ible: it by -passes the 
context checking. So first all the habitats in the system are found, and then their 
context information is displayed.  
(c) The third language function defines three Filters for lists of contexts. These 
filters allow only the contexts to be listed that inherit from a given context, are 
inherited by a given context, or allow a given item to be viewed. The following 
expressions illustrate the use of these three Filters:  
contexts that inherit from desi’s perspective  
contexts that are inherited by archie’s perspective  
contexts that view more than five habitats  
These expressions allow one to explore the structure of the perspectives hierarchy 
and of the way it organizes knowledge.  
Perspectives fill in the layered architecture . Users of a  design environment with 
a perspectives mechanism can build new structures for partitioning the knowledge 
base as it evolves. Thereby, the inheritance network of perspectives provides a 
mechanism for end -users to extend the effective structure of the layer ed 
      Tacit and Explicit U nderstanding in Computer Support                                       262 
  architecture of the system. As discussed in Chapter 7, there is a gap (transformation 
distance-2) in the traditional design environment architecture (e.g., in JANUS and 
PHIDIAS) between the seeded representations of situations and the concrete task 
that is addressed during a given use of the system.  
As shown in Figure 9 -17, this gap is much smaller than that between the 
implementation programming language and the actual task domain, but it is not 
negligible.  
 
 
Figure 9-17. The layered architecture of d esign environments and HERMES. 
This figure extends Figure 7 -2 in Chapter 7.  
 
In addition to providing palette items, catalog examples, and design rationale for 
the general problem domain, the seeded knowledge base in HERMES can partition 
this knowledge in a hierarchy of perspectives. Some of these perspectives can 
include knowledge  that is specific to certain concrete tasks. This mediates between 
the general domain knowledge and specific tasks. In addition, end -users can extend 
the hierarchy to close the gap between the generic domain knowledge and novel 
tasks that arise. The extens ibility of the perspectives hierarchy allows the gap to 
be narrowed as much as is needed to support interpretation in design by eliminating 
gaps in understanding that cause problems. As problems and knowledge evolve, 
the perspectives hierarchy can evolve u nder end-user control to meet the new 
demands and fill the shifting gaps.  
In Chapter 10 it will be argued that the HERMES language can also be used as an 
extensible mechanism for end -users to progressively fill in the gap in the layered 

      Tacit and Explicit U nderstanding in Computer Support                                       263 
  architecture. Defin itions in the language exist within perspectives, so these two 
solutions work in tandem. Together, the HERMES substrate, its perspectives, and 
its language allow the major gaps in the layered architecture to be filled in to an 
arbitrarily fine degree and i n an end-user extensible manner. Figure 9 -17 illustrates 
this. From left to right in the figure are the original transformation distance 
between a general -purpose programming language and a task, the two problematic 
gaps in the traditional layered architec ture of a design environment, and the fully 
layered architecture supported by HERMES. 
 
Many of the features discussed in this section were originally suggested by lunar 
habitat designers and other NASA employees who have reviewed versions of 
HERMES. They have responded very favorably to the potential of the perspectives 
mechanism —as well as the hypermedia and language —to meet their everyday 
needs as designers facing complex, innovative, collaborative, knowledge -based 
tasks. To really know the extent to whic h the perspectives mechanisms can be used 
tacitly under realistic conditions will require extensive interface refinement and 
workplace testing. However, it seems plausible that the perspectives mechanisms 
can be effective in letting the computer manage a s ignificant amount of the 
complexity of knowledge organization behind the scenes of the task at hand in 
which the designer is immersed.  
 
CHAPTER 10. A LANGUAGE FOR 
SUPPORTING INTERPRETATION  
The language presented in this c hapter is designed as an integral part of the active 
computer support of human interpretation in design. It is structured for maximal 
plasticity so that designers can create and modify terms that express their ideas and 
their interpretations of their devel oping designs. At the same time, it must serve as 
a programming language used to instruct the computer in what computations to 
make. As part of a hypermedia substrate for design environments, it needs to 
provide expressive functionality useful for building  user interface components and 
for exploring the hypermedia database.  
If one thinks of a computationally active medium for design as incorporating a 
variety of “agents” that respond to events by computing information for messages 
and displays, then the HERMES language must serve as a language of agents . It 
must be able to analyze information in the database —using the customized 
terminology that particular designers defined within their perspectives —and 
format the results of computations on that information  for display to the designers 
using the system. In the people -centered HERMES system, the agents do not change 
stored information, because such changes are left to the direct control of the human 
designers.  
A central question addressed during the developme nt of the HERMES language was 
how to make the language appropriate to the nature of the human -computer 
interaction that should take place in a design environment. The HERMES language 
grew out of the query language of the PHIDIAS design environment, discuss ed in 
Chapter 7. The PHIDIAS language was an attempt to provide a language that was 
“English-like” in appearance in the hope that it could be used by designers who 
had only a tacit understanding of what expressions in the language meant (i.e., 
what the exp ressions accomplished computationally). However, Part II argued that 
tacit understanding by itself was often insufficient; that interpretation required 
making some things explicit. That was one reason a language is needed at all. 
Designers cannot rely excl usively on pre -linguistic “human problem -domain 
communication” as illustrated by the JANUS system but  must sometimes be able to 
      Tacit and Explicit U nderstanding in Computer Support                                       265 
  articulate their understanding in words. Language and explicit understanding are 
required to discover innovative interpretations , to share ideas with collaborators, 
and to create computer representations. On the other hand, explicit knowledge 
must be founded on tacit understanding,  and it is only required during creative 
interpretive acts, not when tacit understandings meet the nee ds. So PHIDIAS’ 
approach to a tacitly understood language provides a promising alternative to 
traditional programming languages that require a sustained high degree of explicit 
awareness; but it is not sufficient by itself.  
Of course, the scope of the ori ginal PHIDIAS query language was quite limited. The 
HERMES language extended that functionality to meet more of the expressive needs 
of design environments and of the designers who use them. During this process, 
the evolving language was subjected to a ser ies of programming walkthroughs 
(Bell, et al., 1991) to evaluate its usability for writing programs. A primary result 
of these walkthroughs —which are documented in detail in Appendix A —was the 
conclusion that significantly more support was needed for expli cit understanding 
of computational issues. However, previous evaluations of the MODIFIER system 
summarized in Chapter 7 had shown that a purely explicit approach —even with 
significant support mechanisms in the interface —was not the answer either.  
The theo ry of computer support from Chapter 6 suggests that an adequate 
language must support a dynamic movement between tacit and explicit 
understanding . (1) Routine reuse of expressions can be largely tacit. (2) Innovative 
modification  requires a certain amount of explicit analysis. But even here, only the 
domain relationships and certain features of the representations need to be made 
explicit. Much of the computational “doctrine”22 associated with general purpose 
programming languages does not need to be made explicit because it would only 
distract from the problem -domain concerns. Much of this can be kept tacit. The 
HERMES language represents an attempt to relieve the end -user of s uch 
programming doctrine as much as possible.  
Relieving the end -user of technical doctrine of programming does not mean that 
designers using HERMES never need to worry about the explicit structure of the 
knowledge they are taking advantage of. On the cont rary, the analysis of 
interpretation in this dissertation stresses the necessary role of explication in 
furthering normally tacit understanding. Rather, the attempt is merely made to 
 
22 The term doctrine refers to guiding knowledge that must be understood in order 
to use a programming language. For instance, most general purpose 
programming languages require that programmers know doctrine about when 
and how to use iteration control structures. The programming walkthrough 
methodology is designed to assess what doctrine is required for a given task in a 
language.  
      Tacit and Explicit U nderstanding in Computer Support                                       266 
  minimize the amount of doctrine that must be learned that is unrelated to  design. 
Designers are often predominantly visual, holistic, intuitive thinkers; the symbolic, 
detail-oriented, precise, mathematical character of programming language doctrine 
is particularly burdensome for many skilled designers.  
Section 10.1 elaborates on the principles  that have gone into the development of 
the HERMES language, including the necessity of supporting both tacit and explicit 
understanding. The uniqueness of the HERMES language is the way in which it 
strives to combine the problem -domain ce ntered communicative goals of domain -
specific design environments like PHIDIAS and JANUS with the computationally 
expressive goals of general-purpose programming languages like PASCAL and LISP 
through this mix of tacit and explicit understanding.  
Section 1 0.2 shows at an in -depth level how a number of the basic mechanisms  of 
programming languages are available in the HERMES language in ways that require 
minimal explicit understanding of technical doctrine by system users: Abstraction  
is accomplished by ordi nary naming, with no assignment statements. Iteration 
takes place automatically without control structures. Typing is maintained by the 
implicit organization of the syntax options. Recursion  is defined without explicit 
concern for halting conditions. Variables are generally avoided in favor of the 
application of successive operators; where necessary, deictic pronouns can be used 
to reference computational elements. Quantification  operators can be applied 
directly to lists without use of explicitly bound var iables. Other examples of the 
encapsulation of explicit mechanisms of computation in tacitly understandable 
forms are developed in Appendix B, where sample applications using them are 
also described. Of course, users of the HERMES language need to learn do ctrine 
specific to the use of this language, but that is at a higher level of representation 
(closer to concerns of the problem domain) than doctrine for a general-purpose 
programming language. Appendix C defines the complete syntax and semantics of 
the HERMES language.  
Section 10.3 illustrates the use of the HERMES language for defining interpretive 
critics. Interpretive critics provide a final example of the synergy of HERMES’ 
support for interpretation, exploiting the combination of the integrated substr ate, 
perspectives, and the language. First, the critics from JANUS are redefined in the 
HERMES language. Then, the privacy critics  from Chapter 9 are analyzed 
computationally. A number of the mechanisms discussed in Section 10.2 are 
shown at work here. Thi s spells out in some detail one way in which HERMES can 
respond to the challenge from back in Chapter 3, to represent in a computer system 
Desi and Archie’s concerns about privacy. The advantages of the HERMES 
approach are: definitions are made at a higher  level of representation, the 
definitions can be more expressive, and alternative definitions can be organized in 
different perspectives.  
      Tacit and Explicit U nderstanding in Computer Support                                       267 
  10.1.  An Approach to Language Design  
The HERMES language is the result of following several principles arising from the 
theory of computer support and the review of design environment needs in Part II. 
These principles are:  
1. Support a mix of tacit and explicit understanding.  
2. Provide a people -centered approach.  
3. Meet the needs of design environments.  
4. Offer an end -user language for non -programmers.  
 This section will discuss how the HERMES language adheres to these principles.  
1. Support a mix of tacit and explicit understanding.  The HERMES language  
stresses different priorities than traditional computation -centered language 
designs, resulting in a different set of design decisions and a different character to 
the language. The contrast between the H ERMES language and the FP functional 
programming language proposed by Backus (1978), on which the H ERMES 
language is formally modeled, or the PASCAL procedural language in which it is 
implemented makes this point graphically.  
Here is a task like that posed for the programming walkthroughs rep orted in 
Appendix A: Suppose you have a hypertext database with issues in nodes of two 
types: question  and problem ; answers to the issues in answer nodes 
connected by answer links; and arguments for the answers in argument  nodes 
connected by argument  links. (See Figure 10 -1.) Now, you want to know: which 
issues have four or more arguments associated with them  (via their answers).  
 
 

      Tacit and Explicit U nderstanding in Computer Support                                       268 
  Figure 10 -1. A database of design rationale.  
 
This could be accomplished by first defining issues as questions and 
problems  and defining rationale  as arguments of answers . Then 
you could define the query using these newly defined terms as:  
issues that have more than 3 rationale  
Notice how this “program” in the HERMES language is a simple statement in 
domain terms of the desired r esults. All the computations that the computer must 
carry out to produce the query results are implicit: iterating through all the 
questions  and problems  in the database, following each of their answer 
links (if any) and their argument  links (if any), accu mulating and counting their 
rationale  nodes, filtering out all the issues that do not fit the condition.  
The statement of the query in the HERMES language contrasts with its formulation 
in other programming languages. First, it has an appearance that seems  easier for 
non-programmers to understand tacitly than its equivalent in FP, even though the 
HERMES language is formally close to FP: 
a(have-Q-R [>3, rationale]) ° issues 
In this FP declarative statement, much of the computation has been explicitly 
symbolized in abstract mathematical formalisms of application, composition, and 
comparison. Even so, the functional approach of FP using successive composition 
of operators —which HERMES borrows from FP—avoids the step-by-step detail of 
a procedural language. The following procedural pseudo -code shows what this 
query would require in a procedural language, and in fact how it is computed 
(behind the scenes) even in the HERMES system:  
begin 
list0 := empty list;  
list1 := all nodes with Kind = question;  
list2 := all nodes with Kind = problem;  
list3 := list1 append list2;  
for i = 1 to size of list3 do  
 list4 := empty list;  
 for each link type from node do  
  if link type = answer  
      Tacit and Explicit U nderstanding in Computer Support                                       269 
     then for each linked node do  
    for each link type from node do  
     if link type = argument  
      then add node to list4;  
 if count of list4 > 3  
  then add node to list0;  
return list0;  
end;  
Traditional general purpose programming languages are based largely on 
mathematical models of fully explicit expressions. To name some of the most 
popular historical languages, F ORTRAN is based on algebraic formulas, C OBOL on 
business arithmetic, A PL on matrix algebra, and L ISP on symbolic logic. Assembly 
languages are necessa rily closely modeled on the architecture of computer CPUs. 
Most recent languages are derived from combinations of these prototypes. Even 
Backus’ F P language, which is an attempt to break away from the von Neumann 
and lambda -calculus models, is strongly inf luenced by A PL—particularly in its 
outward appearance to the human programmer. All these languages have been 
developed under severe pressure to optimize usage of computer resources 
(memory locations and cycle time). This has led to the following problem: 
programming languages are necessary for empowering people to communicate 
with and through computers; however, the way in which the predominant 
languages are closely based on mathematical models make them difficult for many 
people in many situations to use t o express themselves.  
Natural languages that societies have historically developed for their own 
expression and interpersonal communication needs have very different 
characteristics from these programming languages. They tend to support informal, 
tacit, contextual, situated expression. Thus, they are very dependent on human 
intentional comprehension of semantics and communicative intent. They feature a 
highly generative phrase structure and huge vocabularies that evolve historically. 
They develop under the constraint of cognitive ease for the human speaker and 
vocal brevity (Grice, 1975).  
Now that computer resources are several orders of magnitude less scarce than in 
the past while human cognitive resources are being overwhelmed with the 
complexities of the information age, it seems time to consider designing 
programming languages or end -user languages in which some of the burdens are 
shifted to the computer. That is, while a mathematical basis for languages may be 
important for theoretical reasons, practical  considerations of supporting the needs 
      Tacit and Explicit U nderstanding in Computer Support                                       270 
  of users without burdening them unnecessarily suggest that the logical 
computational structure of the language should often be kept tacitly hidden in favor 
of a higher -level structure close to the user’s explicit con cerns. Computers 
increasingly have the power to manage the translation between these levels to 
relieve the user of that burden.  
The goal of the H ERMES language is to make communication with the computer 
system cognitively and interpretively easier for peop le. It tries to do this by hiding 
many computational details, leaving it up to the computer software to take care of 
them. It allows designers to build their own vocabulary incrementally, using terms 
familiar from their domain of work. The vocabulary can g row through a history of 
use, with different people developing different meanings for terms (in their own 
perspectives) and sharing these meanings (in common group perspectives). The 
language starts out with a shared basic vocabulary, established as a seed ed 
vocabulary by the design environment builders. Terminology in the language can 
be reused and modified by subsequent system users, just as natural language words 
can take on new metaphorical meanings. The language is intended to support 
interpretation, e xplication, and interpersonal communication, not just formulaic 
statement. Section 10.2 will detail what is meant by hiding the computational 
structure of expressions.  
2. Provide a people -centered approach.  The slogan of a “people -centered” 
approach means that the computer system should be controlled by the people with 
whom it interacts at the points where judgmental decisions must be made that 
involve the exercise of intentionality. The HERMES language is designed to 
empower people to express their interpr etations and judgments in ways that can 
affect the computer’s actions and that can also be communicated to other people. 
By making the design environment programmable, the language lets designers 
using the system determine how displays, analyses, and criti cs used in the active 
computational environment are to be defined. Terms used in the definitions of 
these displays, analyses, and critic rules can be defined and modified by designers 
in accordance with their own interpretive perspectives.  
“People-centered” also means that the system interacts with people in ways 
appropriate to human cognitive (interpretive) styles. H ERMES features a language 
for designers (rather than trained programmers) to use. The language is defined as 
a series of subset languages to f acilitate learning by new users . This way, people 
can work with the language at a level that is comfortable for them. When they need 
more explicit control in defining revised expressions to capture their precise 
interpretations, they will have a relatively  easy path to exploring language features 
that are new to them. They can simply move to the next stage of the language in a 
particular area of the language. For instance, if they need a new definition of a 
complex expression, they can expand the beginner’s  dialog box of syntax options 
      Tacit and Explicit U nderstanding in Computer Support                                       271 
  to see the additional intermediate options or they can view the definition of an 
existing expression and modify it gradually. (An interface for doing this is 
discussed under point 4, below.)  
First it should be noted that previ ously defined terms and expressions are used by 
designers most of the time. These can be simply selected from lists of relevant 
terms, even by a novice. Then there is a beginner’s version of the language that is 
similar to the P HIDIAS language, which prove d easy to use for non -programmer 
users. This level of the language suffices for defining or modifying most common 
terms and queries. An intermediate  level provides access to virtually all features 
of the language except those related to graphics. Finally, an advanced  level can be 
used for graphics -related tasks, like defining interpretive critics. Most system 
displays and component interfaces are defined in the language, so they can be 
modified through use of the language. It would be possible to add a full y general 
programming  level to the language by providing a programming language 
interpreter that could treat the syntax options of the H ERMES language as 
predefined functions. This has not been done because the research focus of the 
HERMES language is to s upport interpretation in design and to make a language as 
interpretable as possible for non -programmers. This goal probably does not require 
a computationally complete language. So, the following levels of usage are 
supported by the HERMES language:  
Novice. Even without defining any new expressions in the language, a novice can 
still use most of the HERMES system in a flexible way. It is, for instance, possible 
to define new link Types and node Kinds, although one cannot yet define new 
computed expressions that refer to them. One can also use all the previously 
defined (seeded) expressions in the language: DataLists, Predicates23, conditions, 
queries, critics, etc. Thus, it is possible to define conditional nodes, conditional 
links, or virtual structures (queries embedded in nodes) without writing new 
expressions in the language.  
Beginner . This version corresponds roughly to the original PHIDIAS language. It 
allows the user to define expressions, displays, and critics incorporating Filter 
clauses. With only 15% of the number of options of the full language, the Beginner 
syntax provides a good learning experience for most of the features and 
conventions of the HERMES language. This version of the language features Input 
Associations, a subset of A ssociations useful for eliciting design rationale or 
argumentation. For instance, if an Input Association, deliberation,  is 
defined as issues with their answers with their arguments , 
 
23 The definition and use of Predicates, conditional nodes, and virtual structures is 
described in Appe ndix B. DataLists and other syntax categories are defined and 
illustrated in Appendix C.  
      Tacit and Explicit U nderstanding in Computer Support                                       272 
  then it can be used to control data entry. A special interface feature is  designed to 
create new nodes following the patterns of user -defined Input Associations. Using 
the definition of deliberation , it will prompt for the text of an issue to be 
entered; then it prompts for one or more answers  to that issue; for each 
answer it prompts for one or more arguments . Recursive Input Associations 
can also be defined that prompt for whole trees of data to as much depth as the 
respondent is willing to go.  
Intermediate . The intermediate version of the language expands the 
computational po wer of the beginner version, without, however, including the 
complications introduced by graphics. This corresponds roughly to the level of 
complexity implemented for the version of the language used in the programming 
walkthrough (Appendix A) and in the a cademic advising application (Appendix 
B). Here, the simple data -entry Input Associations become a subset of the more 
powerful and complex Associations. Predicates are a modification of Associations 
to hide some of their complexity when displayed.  
Advanced . This version adds the multi -media capability and more sophisticated 
programming options. Now all the computational capability of the language can 
be applied to nodes of any medium (e.g., vector graphics, sound, video, and 
bitmaps). This is necessary for implementing displays or critics that take into 
account graphical information (distances, spatial relationships, adjacencies, 
volumes, etc.). [This level of the language has been designed (see Appendix C), 
but not yet fully implemented.]  
Programmer . Ultimately, one might want to give a user full programming power. 
In a research prototyping environment, one could simply hand over the source 
code. In a LISP environment, one can allow the user to enter programs as data that 
are then interpreted. However, in re alistic cases where the source code is not made 
available and where speed is too much of a concern to use an interpreted language 
for building the system itself, other mechanisms must be developed. HERMES 
provides a form of procedural attachment implemente d via dynamic link libraries 
(DLLs) in WINDOWS. This lets the user define a certain number of pre -named 
functions, using the full power of object -oriented PASCAL or C++. These functions 
can then be attached to nodes or links in the hypermedia database (see  active 
objects in Section 8.2) and referred to by expressions in the HERMES language. 
[This level of the language has not been explored extensively but  is meant to be 
suggestive as a response to the limits of programming complex algorithms in the 
HERMES language.]  
These levels of the language extend the idea from JANUS of a layered architecture, 
as discussed in Chapter 7. The layers of the language fill in the two gaps that 
appeared in Figure 7 -2: the transformation distance -3 between the system building 
      Tacit and Explicit U nderstanding in Computer Support                                       273 
  environment ( LISP) and the design environment ( JANUS), and the transformation 
distance-2 between the seeded design environment and the actual task domain 
(laying out a particular kitchen). The first of these gaps is filled primarily for 
system builders who are constructing a new design environment or adding new 
components to an existing one. When a design environment is built on top of the 
HERMES substrate, new components take advantage of the substrate functionality, 
including the language. As shown in Chap ter 8, many functions are implemented 
as windows or buttons that evaluate expressions defined in the HERMES language. 
That means first of all that functionality can be defined using higher level terms in 
the HERMES language without the system builder needi ng to work at the lower-
level implementation language. It also means that future end -users can revise the 
way those functions work by modifying the definitions of the terms used in the 
HERMES language, which is available to them at run -time as well. The se cond gap 
is filled primarily for designers using a design environment built on HERMES. They 
can simply use the terms, displays, and critics that have already been defined. If 
they need to modify something, the Beginner version of the language is available.  
If this is not sufficient, they can successively try more advanced versions of the 
language. This provides almost a continuity of layers to support a range of 
understanding from tacit work in the problem domain to explicit software 
programming in the unde rlying programming environment. (See Figure 9 -17 in 
Section 9.3.)  
3. Meet the needs of design environments.  Chapter 7 cited the idea of 
programmable design environments proposed by Eisenberg and Fischer (1992). It 
was claimed there that HERMES could be vie wed as the first implementation of this 
notion. In fact, the design and development of HERMES was driven by the desire 
to include programmability as a central feature of a design environment in order to 
empower designers to define, control, and extend the computational power of the 
software system in which they carry out their design work.  
The desire to have the language refer to, analyze, critique, and display all the 
varieties of knowledge and representations in a design environment —including 
information  from previous designs in a catalog, palette items for use in new 
designs, specification decisions, design rationale, domain distinctions, critic rules, 
etc.—forced the system to become more and more integrated. As the power of the 
language was extended fr om its original restriction to design rationale (in the 
original PHIDIAS query language), more of the knowledge was represented as 
hypermedia nodes that could be linked in one integrated knowledge base. New 
forms of knowledge were also added. For instance,  conditional expressions could 
be defined to implement conditional links, conditional nodes, and critics. The 
increased generality of the system made it easy to add new media, like bitmaps, 
voice, and video as well.  
      Tacit and Explicit U nderstanding in Computer Support                                       274 
  As the language grew in range and power , the number of its syntax options in the 
language increased rapidly, despite extensive efforts to generalize and simplify the 
syntactic structure. In the end, the number of options increased by an order of 
magnitude. Most of these syntax options (those ca lled “simple” options) directly 
reflect elements of the multimedia knowledge representation substrate. Many other 
syntax options (called “computed” options) define combinations of the primitives 
that are needed for useful computations. The appearance of ex pressions in the 
language is dominated by user -defined terms: names of objects, link types, node 
kinds, names of defined sub -expressions. Otherwise, there are just a few “helper” 
words that remind people of the functionality of the options. Little is left in its 
external appearance of the language’s computational internal nature. Thus, the 
HERMES language appears to be a “new” language, although it is really basically 
the result of adapting a stripped -down functional programming approach to meet 
the needs of a design environment.  
Despite its adherence to the notion of a programmable design environ ment, the 
HERMES language is very different from a programmable application like 
SCHEMEPAINT (Eisenberg, 1992). In SCHEMEPAINT, the language is used for 
creation of new objects. In contrast, the HERMES language is “non -imperative” 
(Schmidt, 1986). Evaluati on of expressions in the HERMES language do not change 
state: they do not create anything new. They navigate through the hypermedia 
database and collect lists of existing objects. Of course, by means of user interface 
features, these lists can themselves b e saved as new objects. Also, interface 
features can be designed that use language expressions to organize, modify, or 
even create objects. For instance, a design rationale prompting component in the 
interface can elicit and store new argumentation using t he Input Association syntax 
options as explained in Appendix C. The language is primarily geared to the 
diverse information retrieval needs of designers.  
Design environments have a variety of data retrieval, manipulation, and display 
needs. In a hypermedia -based system like HERMES, these needs can generally be 
categorized into three groups:  (a) to generate lists of information, (b) to selectively 
choose items from lists, and (c) to navigate through the inter -connected network 
of the database. This correspon ds to the three categories of operations that Abelson 
& Sussman (1985) emphasize for functional computer programs: to enumerate, 
map, and filter lists or streams of information.24 The HERMES language syntax 
provides three primary classes of terms to operat ionalize these functions: 
DataLists, Filters, and Associations, as indicated in Table 10 -1: 
 
24 The suggestion to interpret operations in the HERMES language as the processing 
of streams of information in this sense was suggested by both C. Lewis and M. 
Eisenberg, independently.  
      Tacit and Explicit U nderstanding in Computer Support                                       275 
  Table 10-1. Correspondence of language uses, operations and classes of terms.  
 uses operations  HERMES language  
(a) generate lists  enumerate  DataList 
(b) selectively choose  filter Filter 
(c) navigate network  map Association  
 
(a) Many forms of lists must be generated  (enumerated) in a design environment. 
In a system built on top of the H ERMES substrate, virtually all displays in the user 
interface are constructed dynamically from such lists. The H ERMES language is 
designed above all to provide a flexible means for def ining lists of items stored in 
the database and useful for interpretive tasks in the represented domain. In this 
sense, the H ERMES language is a database query language. The H ERMES language 
is optimized for expressing queries in this environment and for re trieving the 
requested information efficiently in useful formats. Unlike SQL (a general-purpose 
query language for relational databases), it is designed for an object -oriented, 
multimedia database in which items are linked together in hypertext style. It d iffers 
from SQL in being non -relational and hypermedia specific . Among the 
information listings available through the H ERMES language are general queries 
and the basic displays used in design environments, such as design rationale issue -
base views, catalogs of past designs, palettes of design components. An example 
of a DataList that computes the items for a display of some rationale created by 
Archie is:  
issues that have creator archie  
(b) Filtering functions of the language are important for implem enting critics and 
for making all displays relative to design decisions encoded in specifications, 
constructions, or design rationale. For instance, using the language one can define 
a display of all catalog items that pass a Filter referring to the existe nce of specific 
palette items in a certain construction, answers  resolved in the design rationale, 
or selections made in a specification listing. Perspectives provide another filtering 
mechanism in HERMES, allowing only nodes that are defined in the curren tly active 
perspective to be processed by the language. The two filtering mechanisms can be 
combined in expressions in the language like:  
issues in context desi’s habitat perspective that have 
creator archie  
      Tacit and Explicit U nderstanding in Computer Support                                       276 
  (c) Navigation  through the hypermedia database ( mapping) is also accomplished 
with the H ERMES language. A good example of such navigation is shown in Figure 
10-1 with the expression:  
issues that have more than 3 rationale  
Here, the expression rationale , defined as arguments of answers , 
navigates from ea ch issue node across its answer links to new nodes and across 
their argument  links. 
The three major syntax categories of the HERMES language (DataLists, Filters, 
Associations) provide the three primary functions required for design 
environments: (a) defini tions of lists of nodes, (b) expressions for filtering out 
nodes not meeting stated criteria, and (c) operations to traverse various kinds of 
associations. These support the situated, perspectival, and linguistic character of 
interpretation by naming repre sentations of things in the design situation, filtering 
out objects for display based on viewing criteria, and providing expressions for 
exploring semantic associations. Objects in each of these three categories can be 
either (1) reused or (2) refined by c ombining expressions in useful ways. This 
defines the six primary syntactic classes; four other classes provide auxiliary terms 
and features. The syntactic classes are listed with brief descriptions in Table 10 -2. 
      Tacit and Explicit U nderstanding in Computer Support                                       277 
  Table 10-2. Major syntactic classes of the  HERMES language.  
 syntactic class  description  
a-1 Datalists options for identifying hypermedia nodes.  
a-2 Computed Datalists  permitted combinations of language elements 
that determine sets of nodes  
b-1 Filters operations characterizing nodes for selection 
b-2 Computed Filters  permitted combinations of language elements 
that define filter conditions  
c-1 Associations  links and other associations of nodes  
c-2 Computed 
Associations  permitted combinations of language elements 
that determine non-primitive Associations  
d-1 Media Elements  nodes of various media: text, numbers, 
booleans, graphics, sound, video, etc.  
d-2 Computed Media 
Elements permitted combinations of media elements, 
e.g., arithmetic or boolean computations  
e-1 Pre-defined 
Terminology  connective terms, measurement primitives, 
fixed values for attributes and types  
e-2 Computed 
Terminology  namable quantifiers and numerical 
comparisons  
 
The central syntax classes  of the HERMES language are (a) DataLists , (b) Filters, 
and (c) Associations . In addition, (d) the Media elements define several syntax 
classes, one for each kind of allowable multimedia content in the hypermedia 
database that is traversed by the language: Character, Number, Boolean, Graphic, 
Image, Pen, Soun d, Video, Animation, and ComputedView . (e) The Terminology 
options provide the connective terms for joining multiple items together and for 
counting items, as well as certain definitions useful for graphical computations; 
these include three syntax classes  for user-definable options: Count, Quantifier, 
Measure; and eight syntax classes that are system -defined: Connective, 
Combination, Distance, Units, Dimension, Attribute, Value,  and LanguageType . 
      Tacit and Explicit U nderstanding in Computer Support                                       278 
  In addition there are three hypermedia classes that are part  of the syntax: Contexts, 
NodeKinds  and LinkTypes . The syntax classes are divided into Simple and 
Computed options. The Simple options define a single operation for producing a 
result. The Composite options define legal combinations of applying one operati on 
to another. This defines the operator algebra that is at the heart of the HERMES 
language. It is discussed below. Table 10 -3 (below) provides sample options from 
each of the classes listed in Table 10 -2 (above).  
Table 10-3. Examples of syntactic options  for the H ERMES language.  
 syntactic class  example 
a-1 Datalists all database items of a specified 
NodeKind  
a-2 Computed Datalists  items of a DataList that pass a specified 
Filter 
b-1 Filters items that are of a specified NodeKind  
b-2 Computed Filters items that pass Filter1 and also pass 
Filter2 
c-1 Associations  a Link Type (e.g., children)  
c-2 Computed Associations  Association1  with their Association2  
d-1 Media Elements  a real number (e.g., 3.14)  
d-2 Computed Media Elements  the total of all numbers in a specified 
DataList 
e-1 Pre-defined Terminology  closest distance between two graphic 
items 
e-2 Computed Terminology  a Distance is greater than a specified 
Number  
(e.g., too near: closest distance is less 
than 5 feet)  
 
      Tacit and Explicit U nderstanding in Computer Support                                       279 
  The DataList, Filter, and Association options constitute the majority of the syntax 
options. The Simple options are all defined as primitive operators. For instance, 
Simple DataLists return a node or list of nodes as their result. DataList, Filter, and 
Association (both Simple and Computed) evaluation functions all take a DataList 
as input and return a new DataList as a result. This DataList result format acts as a 
stream of data items that passes through the operators to generate new items, filter 
out items that were there, or map from the old items to associated new items. 
Because of this uniform format, any of the operators can be applied successively 
to the results of any other operators. This allows the unlimited nesting of phrases 
and application of op erators that makes the HERMES language highly generative.  
In HERMES, only certain combinations of applications are permitted, as defined by 
the Computed options. If the Simple options were incorporated as predefined 
functions in a general programming language like FP or SCHEME, then any 
combinations of operators could be evaluated. However, a judgment has been 
made in designing HERMES to limit the combinations to semantically meaningful 
and useful options. That accounts for the seeming proliferation of options. In fact, 
however, the majority of options are nothing but comb inations of other options 
applied to each other. For these combination options, the semantics are trivially 
defined, as shown in Appendix C in which the denotational semantics and the 
corresponding implementation code for the evaluation function of one suc h 
combination option is shown. The HERMES language is a carefully constrained  
language, designed to promote relatively tacit usage by structuring the choice of 
operation combinations to avoid many problematic expression definitions and to 
guide the languag e user. 
4. Offer an end -user language for non -programmers.  The use of the language 
in HERMES can be made appropriate for non -programmers in many ways through 
interface features. Some examples were already given in Chapter 8. Consider how 
navigation  through the hypermedia database (mapping) is accomplished with the 
HERMES language. An example of such navigation is shown in Figure 10 -2. A 
textual node has been selected in a Design Rationale  window by clicking on it. 
This brings up the Navigating the Hypertext  window. The selected node has been 
displayed in the top of this window and the default option of “Navigate out -going 
links” has been chosen. The list of “Out -going Links” displays “issue ,” indicating 
that the selected node is associated with out -going links of type issue to other 
nodes. The list of Predicates25 displays three terms that have previously been 
defined in the H ERMES language; these terms are all defined with expressions that 
include issue as their initial traversal, so they are relevant to the  selected node 
 
25 Predicates are a special form of computed Association. They are explained in 
Appendix B.  
      Tacit and Explicit U nderstanding in Computer Support                                       280 
  that has issue links. If the user had selected “issue” under “Out -going Links ,” 
then a new Design Rationale window would have been displayed listing all the 
nodes navigated to by following issue links from the original selected node. In 
the case shown in the figure, the user has instead selected the Predicate 
discussion . Discussion  is defined in the H ERMES language (either in the 
seed or by a previous user) as a series of link navigations beginning with issue 
links. So the display produced in the new window is an indented list resulting from 
the navigations defined by the language expression named discussion . 
 
discussion of issue;
W hat are the design considerations for bunks?for bunks?
 
Figure 10 -2. An example of hypermedia navigation.  
 
The example just  given illustrates a number of points about language usage in 
HERMES. First, expressions (like discussion ) can be reused without explicit 
concern for their detailed definition, particularly if their name indicates their 
function adequately. Second, rather complex displays can be defined relatively 
easily. If one wanted to, one could modify the definition of discussion  or 
define a new term based on it. The new term could use Filter conditions to 
eliminate items selectively as well. For instance, one could de fine a new Predicate 
      Tacit and Explicit U nderstanding in Computer Support                                       281 
  bunk discussion  as: discussion that contains ‘bunk .’ Then 
the list of Predicates displayed in the Navigating the Hypertext  window would 
include bunk discussion  and selection of this option would result in a display 
that only listed ite ms including the word “bunk .” Third, language usage can be 
integrated into the user interface so that it feels like tacit navigation through 
hypermedia rather than explicit querying with a language. The use of this language 
need not have the look and feel of programming, even when new expressions are 
being defined for accomplishing arbitrarily complex computations.  
When an expression must be explicitly programmed, interface support is available 
to reduce the cognitive burden of recalling syntax options, str ict formats, 
expression names, or terminology spellings. As part of the attempt to reduce 
programming errors that would frustrate a non -programmer, a direct manipulation 
interface is provided for use, reuse, modification, and creation of expressions in 
the HERMES language. Strictly speaking, this is not part of the HERMES substrate, 
but belongs to the interface of a design environment built on top of the substrate. 
It is presented here simply to suggest one solution to the problem of supporting 
people to us e the HERMES language with minimal cognitive overload.  
* By presenting all relevant options on the computer screen at each stage and 
requiring expressions to be built up by choosing from these dialog options, the 
user is relieved of having to remember the various legal options.  
* Similarly the problem of entering the precise proper format and spelling is 
solved. Novice programmers are particularly frustrated by punctuation and 
spelling errors during program input.  
* The interface presents definitions of terms in a readable format. Given that 
expressions in the HERMES language often read much like English, it is 
important to avoid the impression that the system can understand arbitrary 
English formulations. The restric tion to a visible menu of choices makes the 
restrictions clear and unavoidable.  
* The same dialog boxes that are used for defining new expressions encourage 
the reuse of previously defined expressions. Old definitions can be reviewed 
with the dialogs to se e their internal structure, and the definitions can then be 
modified and reused.  
Figure 10 -3 shows the three dialog boxes for defining a DataList expression. This 
is typically the starting point for defining expressions in the language, such as 
queries or critics. It is also possible to start with other dialogs to define conditional 
expressions, numerical computations, and so on. The leftmost dialog, labeled 
“DataList options,” is the first dialog to appear under conditions in which one 
needs to define a ne w DataList. If one wants to select a previously defined DataList 
expression —whether defined as part of the HERMES seed, by other system users 
      Tacit and Explicit U nderstanding in Computer Support                                       282 
  or by the current user —then a pick -list of the names of all defined DataLists is 
used instead.  
 
 
Figure 10 -3. Dialog boxes for defining DataList expressions.  
 
This programming interface incorporates the breakdown of the language into a 
series of levels for users with different degrees of experience in using the language. 
This is an example of the mixture of support for tacit and explicit understanding. 
Even when the system user needs to make interpretations explicit and state them 
in the programming language, this burden is softened by providing a direct 
manipulation, construction kit interface for defining expressio ns and by providing 
a layered architecture of many levels of successive complexity.  
The leftmost dialog presents the Beginner’s version of the syntax . The heart of this 
dialog is the list of seven small circles, the radio buttons for selecting one of the 
three Simple DataList options or one of the four Composite DataList options. The 

      Tacit and Explicit U nderstanding in Computer Support                                       283 
  first of these options allows the user to simply select a node from a pick -list, which 
will be displayed when this option is chosen. The second option defines a DataList 
consisting of all nodes in the database that are of a specified NodeKind. If this 
option is selected (by clicking the mouse on its NodeKind button), a pick -list of 
the names of all defined NodeKinds is displayed. The third option retrieves a 
DataList expression that has been previously defined and saved.  
The Composite DataList options lead to other dialog boxes to define constituent 
parts of the composite expression. The first of these, for instance, has three buttons: 
“DataList ,” “Combination ,” “DataList .” If this option is selected, then each of 
these buttons must be pressed with the mouse before the new expression can be 
saved. Pressing the first (or the third) of these buttons brings up another copy of 
the same dialog box so that the constituent DataLists may  be selected. For instance, 
to define a DataList named issues as questions and problems , use this 
option and press the first button. When the new DataList dialog appears, select the 
first Simple DataList option and choose questions  from the pick -list that 
appears. Then click the “ok” button at the bottom of the new dialog to confirm this 
choice. The new dialog will disappear. Then press the “Combination” button. This 
will bring up a dialog listing the five Combination options. Simply select the and 
option and click the “ok” button. Then define the DataList for the third button as 
problems . Now the expression questions and problems  will show in 
the small window near the bottom of the DataList dialog box. Press the “save 
DataList” button below there. A small d ialog will ask for the name of the new 
DataList that has just been defined. Type the word issues and the new 
expression will be part of the HERMES system. 
Below the list of options in the DataList dialog are buttons labeled “more 
DataLists” and “graphic Da taLists.” These bring up the dialogs with the 
Intermediate and Advanced DataList options , respectively. They are also shown 
in Figure 10 -3. They work the same way as the options in the first dialog, which 
remains on the screen and controls the overall expr ession definition process. This 
is how a user advances from the Beginner to the Intermediate or Advanced levels 
of the language based on their specific needs.  
One more button should be mentioned in the basic “DataList options” dialog box. 
That is the upper most button: “reuse a DataList .” Pressing this button brings up a 
pick-list of defined DataLists. When one is selected from this list, the list 
disappears and the definition of the selected DataList appears in the dialog. First it 
appears in the display wi ndow in its narrative format. But it also appears in the 
options in the sense that the option that was used for defining it is now selected in 
the dialog. Pressing the buttons for that option will bring up dialogs that are also 
already displaying the const ituent parts. This provides a way of exploring the 
structure of a defined expression. If anything is changed on the subsidiary dialogs 
      Tacit and Explicit U nderstanding in Computer Support                                       284 
  and confirmed and saved, then the definition of that expression will be modified 
accordingly (within the currently select ed perspective).  
While the foregoing description and its accompanying figure may seem 
complicated, that is partly because it is harder to describe this process explicitly in 
words, covering most of the various possible actions, then it is to use the direct  
manipulation interface to make selections needed to accomplish a specific task.  
 The HERMES language represents an attempt to push a particular approach to 
language design as far as possible. This is what makes the HERMES language 
distinctive. The approa ch is motivated by the theory of computer support of 
interpretation. It includes an effort to balance support for tacit and explicit 
understanding, promoting tacit activity whenever possible, even during the 
accomplishment of explicit programming tasks. It  tries to develop an expressive 
and extensible programming language for people like designers who may not be 
experienced at computer programming. To do this, it hides many of the 
computational mechanisms (as described in the following section ) and constrains 
the syntax of the language. Of course, there are trade -offs involved in keeping 
mechanisms hidden and in limiting options to enforce meaningfulness of 
expressions. The H ERMES language has great flexibility and expressivity. It is 
infinitely generative and arbitrarily complex. But it is far from being Turing 
complete. There are many definitions of lists that cannot be expressed in it, but that 
are relatively straight -forward to  program in P ASCAL or LISP, for instance. 
Subsequent examples and analysis in the remainder of this chapter and in the 
Appendices should show the language’s ability to formulate easily and tacitly the 
expressions most useful for design environments, as wel l as pointing out the 
limitations that can arise in more complex circumstances.  
10.2 Encapsulating Explicit Mechanisms in Tacit 
Forms  
The HERMES language has been designed to minimize the amount of programming 
language doctrine required as explicit knowled ge by people writing and reading 
expressions in the language. This has been accomplished by hiding a number of 
programming language mechanisms in the syntax options of the HERMES language 
so they can be used with only a tacit understanding of their functio ning. This 
section illustrates what is meant by this approach. A number of important areas of 
programming language doctrine that require explicit understanding for the use of 
languages like LISP or PASCAL are incorporated in the syntax options, evaluation 
      Tacit and Explicit U nderstanding in Computer Support                                       285 
  processes, and user interfaces of the HERMES language in ways that can be used 
without explicit understanding.  
1. Abstraction in HERMES takes place by simply giving a name to an expression 
that has been defined; there is no explicit assignment statement. A ll 
expressions in the H ERMES language can be named and the names may be used 
wherever the corresponding expression could be used.  
2. Iteration is implicit in HERMES. For instance, in the example of displaying the 
discussion  of an item from the Design Rati onale window, all the issue 
links from the item’s node were followed. Normally, this would be expressed 
in a traditional programming language as some form of iteration (a for-loop 
or a recursion). However, in the H ERMES language it is not expressed at all,  
but merely assumed in the declaration calling for a list of the issues.  
3. Typing of expressions is enforced by restrictions on the allowable syntax 
options, without the user needing to be aware of this.  
4. Recursion is an important technique for naviga ting successive links in 
hypermedia networks using the H ERMES language, but users need not be aware 
of it or worry about halting conditions.  
5. Variable binding occurs as a natural result of the syntax of expressions, but 
explicit variables are not used.  
6. The syntax allows one to quantify expressions by asking for all items, checking 
for at least one item, and so on, but the computational implementation of these 
is hidden from the user.  
7. Conditionals can be stated in explicit if / then format or impl ied through more 
tacit formats.  
1. Abstraction . The importance of abstraction  has been emphasized by many 
leading language designers (e.g., Liskov, et al., 1977; Cardelli & Wegner, 1985; 
Abelson & Sussman, 1985; Wirth, 1988). From a people -centered perspec tive, the 
importance of abstraction in definition of expressions in a programming language 
is that a complex expression can be hidden under an easy -to-use name that 
corresponds to terminology in the application domain. That means that the name 
can be used in a relatively tacit way once it has been defined explicitly.  
To use an example from Chapter 3, it may be quite difficult to define an operational 
definition of privacy for lunar habitats. Such a definition must be spelled out in 
complete and explicit de tail (see Section 10.3 below for such a definition) so that 
the computer system can use it. However, once defined, the definition can be stored 
under the name privacy . From then on, designers using the system can make 
use of the term privacy  without being concerned about all the computational 
      Tacit and Explicit U nderstanding in Computer Support                                       286 
  details. In fact, the term may have been defined as part of the system’s knowledge 
seed by the software developers or by some intermediate knowledge engineer, so 
that the lunar habitat designers never need to be concer ned with (or develop the 
skills to understand) the technical details of implementation. This is a case in which 
the analysis of interpretation provides a new argument about the role of abstraction, 
an old technique. Based on this argument, H ERMES in fact places considerable 
emphasis on this form of abstraction in the design of the H ERMES language, 
allowing every object stored in the computer memory —including all defined 
expressions and sub -expressions in the language —to be referred to by user -defined 
names. 
The use of abstraction in HERMES supports extensibility of the language. Not only 
can link Types and node Kinds be user -defined (as they already were in PHIDIAS), 
but so can the language’s namable terminology elements: Count, Quantifier, and 
Measure. For instance, a new Count term, several , could be defined as: more 
than 2 and less than 7 . By naming the expression “ several ,” a user 
can then make use of this term without worrying about its precise definition. Of 
course, if another user interprets the term several differently, the definition can 
always be explored and modified through the interface to the language. Similarly, 
Measure terms can be added to the language, like “ set off from ”: central 
distance is less than 24 inches and closest distance is 
more than 4 inches  
In Section 9.1’s scenario in which the notion of privacy is made operational, the 
scale of privacy values from 1 to 9 was abstracted by the definition of the following 
Number terms:  
very public:   1 
quite public:  2 
public:   3 
somewhat public: 4 
neutral:   5 
somewhat private:  6 
private:   7 
quite private:  8 
very private:  9 
These definitions allow designers to think in tacit problem domain terms rather 
than in the explicit quantitative terms required by the computer. The abstractions 
are constructed tacitly by simply supplying a name when an expression is defined; 
there are no explicit assignment statements in the language.  
2. Iteration . Much traditional programming language doctrine has to do with 
iteration: for loops versus while control statements, recursive list processing, 
      Tacit and Explicit U nderstanding in Computer Support                                       287 
  sequential comparisons, etc. In HERMES, there are no explicit control structures for 
iteration. Yet, iterating through lists (e.g., all the nodes of such and such a 
description, or all the links of a certain Type from a node) is ubiquitous in its 
central task of navigating through hypermedia. In the HERMES language, the 
various iterative tasks of the design environment and of its hypermedia substrate 
are encapsulated in primitive syntax options.  
A Simple DataList can be  defined by a NodeKind or LanguageType; these options 
iterate through the database index to retrieve all nodes of the specified category. A 
Simple Association can be defined by a Link Type; this option iterates through all 
the links of the specified Type f rom a given starting node. The option, all 
associations , iterates through all of a node’s out -going links; inverse  
Association iterates in -coming links; parts iterates content links. Each of these 
options returns the list of all nodes at the other end of these links. The options are 
implemented with iteration control structures, but the user need not be aware of 
this. 
Simple Filters also iterate through lists o f nodes. They test each node successively 
to see whether it meets some condition. The nodes that meet the condition are 
returned. For instance, the expression, arguments of answers of the 
bunk locations issue that are of kind pro -argument , will 
be evaluate d by iterating through all the nodes at the ends of the specified argument 
links and testing which of them are of node Kind pro-argument .  
Several of the Number options are also implicitly iterative, returning a count of 
elements in a list, a minimum, maxi mum, total, or product of the values. One 
Number option even iterates through all combinations of two or three graphical 
objects to return a list of the distances between them. To test for an acceptable 
work triangle in a kitchen, a designer can simply tak e the minimum value of this 
list of distances, without needing to worry about the details of iterating through all 
the combinatorial possibilities if there are multiple stoves, sinks, or refrigerators in 
the kitchen.  
3. Typing. The constrained syntax of th e HERMES language provides an implicit 
typing system. Like the strong typing system of languages like PASCAL, it avoids 
syntactic combinations that would be meaningless or cause conflicts. However, it 
is enforced “behind the scenes” so users do not have to  be aware of it as a typing 
system. Types are not declared explicitly by the user.  
The Simple syntax options are categorized in the syntax classes discussed in the 
previous section, such as DataList, Filter, and Association. These 25 classes are 
the types of the HERMES language. A typical Computed syntax option combines 
terms from several of these classes. For instance, one Computed DataList option 
      Tacit and Explicit U nderstanding in Computer Support                                       288 
  is: DataList Combination DataList. This joins any two expressions of type DataList 
with any expression of type  Combination, like and or or.  
Notice that each of the computed syntax options listed in Appendix C refers to one 
or more syntax classes (or types). Legal combinations of these types are defined 
by the options of the syntax. This is a convention of the lan guage; it would be 
possible to define combinations of individual options or to distinguish between 
categories of options like Simple and Computed —but that would be a different 
language. For instance, example a -2 in Table 10 -3 allows a DataList to be define d 
as a Filter applied to a DataList. This means that any expression of type Filter can 
be applied to any expression of type DataList and the result will be a legal 
expression of type DataList. The DataList used as a component in this definition 
may itself be a Computed DataList composed of several components. By applying 
these rules repeatedly, one can build up well -defined expressions of arbitrary 
nested complexity.  
The set of defined legal options has been carefully designed to permit the 
construction of  a broad range of expressions to meet the needs of people using a 
hypermedia -based design environment. While generality of expression has been a 
priority, an attempt has also been made to exclude combinations that would lead 
to problems for the users. Anot her constraint has been to keep the sheer number of 
options as small as possible. Of the 110 options defined, only a small number will 
be used most of the time; many are for advanced techniques primarily necessary 
for internal use building interface functi onality or for complex graphical 
computations.  
4. Recursion . Recursion was already available in the PHIDIAS query language. A 
simple example is the definition of issue trees  as: issues with their 
issue trees . Here, the definition recursively incorporates i ts own name. This 
is useful for navigating hypermedia networks to arbitrary depth. The evaluation 
proceeds from a node across all its issue links to new nodes, across their issue 
links, etc. The recursion terminates at nodes that have no issue links. This 
graceful termination condition is built into the implementation of the Simple 
Association option, Link Type. Therefore, users of the language do not need to be 
concerned about explicitly stating a halting condition for the recursion, a step that 
frequently  causes bugs for novice programmers. The implementation supports 
what a naive user would tacitly expect, or at least what one would come to expect 
after having been exposed to some sample recursive definitions in the language.  
5. Variables . The HERMES language experiments with how far a programming 
language can go without the use of explicit variables. Variables are perhaps the 
first serious barrier that most programming poses for people who are not 
mathematically inclined or experienced. Lack of explicit v ariables differentiates 
      Tacit and Explicit U nderstanding in Computer Support                                       289 
  the HERMES language clearly from procedural languages (that use variables for 
iteration counters, subroutine parameters, array indices, etc.), functional languages 
(that use variables for lambda parameters), and logic languages (tha t use variables 
for quantification).  
HERMES makes use of operator application, applying successive operations 
directly to the results of previous operations without need for abstract variables to 
relate the operations to the operands. This works smoothly in simple cases and 
supports tacit expectations. When expressions are nested several levels deep, the 
relations of what operations are to be applied to which operands can become 
confusing. (Several examples of this are given in Section 10.3 and in Appendix  B, 
in which moderately complex applications in the HERMES language are discussed.) 
For these cases, three special “deictic variables” have been defined. These are not 
abstract variables, but terms that perform much the same concrete role as deictic 
pronouns in natural languages.  
The deictic variables of HERMES are the following Simple DataList options: that 
(last subject) , this (expression) , and those items . They are 
used within an expression to refer to a node or list of nodes that has been previously 
computed. They disambiguate the application of Predicates and allow intermediate 
results of computations to be displayed or reused without recomputing them. 
Examples of the use of the it and them deictic variables will be seen in the 
analysis of the privacy critics in the following section. The this 
(expression)  variable can be useful in defining recursive terms; issue 
trees can be defined as: issues with their this (expression) , 
where this (expression)  refers to the term issue trees  that is itself 
being defi ned. 
It should be noted that the lack of variables is a trade -off in the design of the 
HERMES language. It is intended to reduce the cognitive overhead of the use of 
explicit variables. However, it probably introduces the most severe restriction in 
the expressibility of the language for relatively complex computations, making 
critics like the privacy gradient critique  in Section 10.3 and the 
advice critic in the academic advising application in Appendix B difficult to 
construct and comprehend. However, the language is not meant primarily to be 
used for building computationally complex systems, but rather for supporting the 
incessant reuse and modification of relatively simple definitions of terms needed 
for displaying, analyzing, and critiquing hypermedia re presentations of designs.  
6. Quantification . The HERMES Quantifier type is provided to support 
quantification. As just discussed, it does not use the explicit bound variables of 
predicate calculus or PROLOG. Three examples show how it is used:  
      Tacit and Explicit U nderstanding in Computer Support                                       290 
  chairs that are near to at least one table in archie’s 
habitat 
issues that have no answers that include “bunk”  
if all privacy ratings of parts of archie’s habitat are 
more than quite private  
As should be clear from these expressions, the computation of a q uantity like all 
is carried out internally by the implementation of this syntax option and need not 
be an explicit concern of the user.  
7. Conditionals . Conditionals are important in a design environment. They are, 
for instance, used for critic rules, conditional links, and conditional nodes. In 
addition to the standard syntax form for conditionals, if Boolean then 
DataList1, else DataList2 , HERMES offers the following form: 
either DataList1 or DataList2 . The second format is more supportive 
of a tacit approach. Its evaluation first computes DataList1. If it returns something, 
that is returned as the result of the whole conditional expression; if it retur ns no 
nodes, then DataList2 is computed,  and its results are returned for the conditional. 
For instance, if one wants to list the answers to an issue if there are any and give a 
warning message otherwise, one can define the following conditional expression :  
either answers of my issue or “There are no answers to my 
issue.” 
The implementation of this option takes care of the checking of whether there are 
any results of the first part and deciding whether or not to compute and return the 
results of the second  part. 
10.3 Defining Interpretive Critics  
Interpretive critics . Interpretive critics in the Lunar Habitat Design Environment 
(LHDE) built on HERMES play much the same role as critics in JANUS and triggers 
in PHIDIAS, as discussed in Chapter 7. In LHDE the critics are not active the way 
that JANUS’ critics were, although a different design environment built on the 
HERMES substrate could make use of the same mechanisms as JANUS to activate 
critics associated with a design unit whenever an instance of that uni t is created or 
moved in a design construction. In LHDE and PHIDIAS II (which is also built on 
HERMES), critics are tied to user interface buttons to provide PHIDIAS-style 
triggers. Interpretive critics can be used whenever a user has them evaluated by 
means of any interface mechanism. That is, designers can define and evaluate 
interpretive critics very freely, without necessarily having them tied to design units 
      Tacit and Explicit U nderstanding in Computer Support                                       291 
  in a palette component or to predefined buttons in a construction interface. 
Interpretive  critics are, thus, more general than the critics and triggers of the related 
systems they were inspired by.  
Interpretive critics are defined using the HERMES language. They can take 
advantage of all of the expressive power of the language. Basically, a critic i s any 
expression in the language that analyzes the state of the hypermedia database. 
Typically, a critic looks for certain features in a graphical construction and displays 
a message or takes some other action depending on whether the feature is found or 
not. The message can include design rationale or examples explaining the 
reasoning behind the critic definition. It might, for instance, include a selection of 
items from the design rationale, through which the designer can browse, e.g.:  
privacy check of ha bitats and deliberation of privacy issue  
By using the HERMES language, interpretive critics can be more general, more 
expressive, and more complex than JANUS critics. They are not restricted to spatial 
relations of individual design units in the palette o r to a single construction area. 
They can analyze, for instance, multiple habitats in the database, evaluate global 
characteristics of designs (like number of parts or absence of particular parts), and 
make their analysis dependent on other conditions in t he database. Examples of 
complex critics are the privacy critics described in Chapter 9 and the academic 
advising critic discussed in Appendix B.  
Because the whole language can be used and the whole database accessed, critics 
can be made dependent upon inf ormation in other designs, in an issue base, or in a 
distinct specification component (as indicated in Chapter 8). The critics can play 
an important role in integrating diverse pieces of information in the system.  
Critics in HERMES are called interpretive  because of the synergy which they 
engender between the HERMES language and the mechanism of interpretive 
perspectives. This is best explained with an example. Suppose Desi defined a critic 
named refrigerator access  as: 
if refrigerators are too  near doors then refrigerator 
access message  
Now, if Desi had defined too near  as closest distance is less 
than 5 feet  but Archie had modified too near  to be closest distance 
is less than 3 feet , then the refrigerator access  critic will be 
“interpreted” di fferently in Archie’s perspective then in Desi’s. Since the language 
allows critics to be built up to arbitrary levels of complexity, a critic like the 
academic advising  critic (in Appendix B) may be dependent upon the 
definition of many sub -expression, wh ich may be defined differently in different 
perspectives. The point in the example is that Desi and Archie have different 
      Tacit and Explicit U nderstanding in Computer Support                                       292 
  interpretations of what it means for something in the kitchen to be too close to 
something else. In another domain (e.g., molecular ch emistry or astronomy) the 
term too near  might need to be redefined more drastically. The perspectives 
mechanism assures that the evaluation of an interpretive critic will always interpret 
the terms and sub -expressions of the critic’s definition within the context of the 
current active perspective.  
Comparison with JANUS critics. HERMES critics are defined in the high-level 
representations made available through the language. That is, they can be defined 
using vocabulary that is close to the problem domain, w ithout needing to think in 
the explicit functional manner of the LISP syntax used by MODIFIER. All of the 
critics used in systems like JANUS and MODIFIER can be concisely stated in the 
HERMES language. Following are definitions of terms used for defining t hese 
critics: 
next to:  closest distance is less than 4 inches  
far from:  closest distance is more than 30 inches  
close to:  central distance is less than 60 inches  
near:  closest distance is less than 12 inches  
set off from:  close to and not next to  
work triangle distances:  list of closest distance in 
feet among sink, stove, refrigerator  
Using these terms, the equivalent of JANUS’ critic rules can be concisely and 
readably defined as follows in the HERMES language:  
all stoves are set off from sinks  
no stoves are next to refrigerators  
all stoves are far from all doors and windows  
all dishwashers are next to sinks  
all refrigerators are far from all windows  
refrigerators are close to doors  
sinks are near windows  
the minimum work triangle distances are less th an 23 
In MODIFIER, the critic rules are meant to be available to and modifiable by the 
end-user. However, they are written in LISP. Thus, a designer wishing to modify a 
critic rule in MODIFIER must be at least somewhat familiar with the complexities 
of LISP doctrine, including its non -intuitive Polish notation. In addition, 
      Tacit and Explicit U nderstanding in Computer Support                                       293 
  conventions of MODIFIER’s property sheets must be understood and used to make 
explicit computational decisions. For instan ce, the HERMES critic, 
all stoves are set off from sinks  
appears in MODIFIER’s property sheets as:  
not_next_to (stove , sink )   apply to: all  
near (stove, sink)    apply to: one  
 
The parentheses of LISP in MODIFIER’s critics are replaced in HERMES by an 
implicit nested phrase structure that is familiar to people from natural language. 
This nesting is unambiguously determined at definition time through the tacit use 
of the interface to the language discussed above. F igure 10-4 shows the explicit 
phrase structure for the critic rule just discussed. Note that this diagram not only 
expands the definition of set off from  (which has been abstracted in the rule 
statement), but also indicates the clauses at least one  and in kitchen , 
which are computationally important but are implicit in the expression that the user 
sees and manipulates. That is to say, both the structure of the critic and substantial 
contents of it are kept implicit and are hidden from the user’s explicit 
understanding, in much the sense that the explicit phrase structure of normal 
speech is not usually an object during ordinary communication.  
 
      Tacit and Explicit U nderstanding in Computer Support                                       294 
   
Figure 10 -4. Phrase structure of a HERMES critic rule.  
The critic rule can be read from the leaves of the tree: all stoves are set 
off from [at least one] sinks [in kitchen] . Phrases in brackets 
are implicit. The phrase  set off from  can be expanded as: central 
distance is less than 60 inches and not closest distance 
is more than 4 inches . 
 
The point of this diagram is  not to show how complex interpretive critics are 
internally, but on the contrary to show how rules that are inherently quite complex 
can be expressed in apparently relatively simple expressions (like, all stoves 
are set off from sinks ), which hide much of  the complexity that the user 
ordinarily does not need to be concerned with.  
Analysis of the privacy critics . The privacy critics developed in the scenario of 
Chapter 9 provide a good example of a complex definition in the HERMES 
language. A close look can  reveal both some of the advantages of using the 
language and also some of the difficulties.  

      Tacit and Explicit U nderstanding in Computer Support                                       295 
  The task of the privacy critic is to determine if public areas of a lunar habitat are 
too near to private areas. So first the notions of privacy and nearness must be 
operationalized and applied to areas within habitats. A privacy values  scale 
from 1 to 9 is established and these Number values are given names from very 
public (1) to very private  (9). Links of type privacy rating  are 
attached to various parts of the h abitats and connected to nodes with appropriate 
privacy values . The Measure term too near  is defined as:  
closest distance is less than 5 feet  
Now it is possible to define public and private areas:  
public area: parts that have privacy ratings that are le ss 
than somewhat public  
private areas: parts that have privacy ratings that are 
more than somewhat private  
These are Computed Associations or Predicates. They look at all the parts of 
whatever DataList they are applied to. These parts are then Filtered by checking if 
they have privacy ratings  links and furthermore if the nodes connected by 
such links lead to values greater or less than the values named somewhat 
private  or somewhat public . Any parts found that have at least one such 
link will be returned by these expressions.  
It would be more efficient to make these definitions for immediate parts  (i.e., 
top level parts of the habitats) rather than all parts (including subparts, all the 
way down to primitive graphical polygons). That would save considerable 
traversal of the hierarchies of graphical objects making up the habitats. However, 
that would require that the person defining the expression knew that al l the relevant 
public and private parts were defined as top level parts of the habitats. If the 
designer defining this expression had also constructed the habitat graphic this 
would be possible. For the sake of generality that has not been assumed in this 
discussion.  
Note that a given part might have multiple privacy rating  links (even in the 
same perspective). The definitions above only require one such link meeting the 
Filter condition. Thus, a given part could be returned as both a public area  
and a private area . Such an anomaly would quickly show up as a problem 
area in the critic results. In general, the ability of the definitions to deal 
reasonably with such multiple definitions  is an aspect of robustness in the HERMES 
language. It is discussed in App endix B under the topic of defeasible reasoning.  
      Tacit and Explicit U nderstanding in Computer Support                                       296 
  The next step is to create a display of problem areas , that is, private 
areas that are too near to public areas . This can be accomplished with the 
following definition of problem areas :  
private areas that are too near public areas of that (last 
subject) with those items  
The idea here is to select one private area  of a habitat at a time and for each 
one to then iterate through all the public areas  of the same habitat and list the 
public areas  that are too near to the selected private area . Both 
private areas  and public areas  are Associations that operate on the 
same habitat (DataList) when the overall problem areas  Association is applied 
to a habitat or a list of habitats.  
The Filter syntax option used in th e definition of problem areas  has the 
following form: Measure [Quantifier] DataList [ in Graphic]. The Measure has 
already been defined and stored with the name too near . The optional 
[Quantifier] defaults to an implicit “ at least one .” The DataList that th e 
private area  is to be measured to is each public area  of whichever 
habitat is currently being operated on by the problem areas  Association. To 
define a DataList consisting of these public areas , the deictic variable, that 
(last subject) , is used to refer  to the habitat to which the problem areas  
Association is applied. This deictic refers to the most recently defined “subject” to 
which operators are being applied, namely the “subject” of the problem areas  
Association. Here the term “subject” refers to the  DataList that is the input to the 
evaluation of an expression. A stack of recent subjects is maintained in order to 
implement this deictic variable. The parenthetical explanatory phrase, “ (last 
subject) ,” departs from the tacit feel of the language in ord er to alert the reader 
to think explicitly about the computational structure of operator application in this 
case because a reference is being made to some term outside the immediate 
expression —namely to the subject to which this expression will be applied . 
The optional [ in Graphic] phrase defaults to in that (last subject) , 
which, again, refers to the “subject” of the problem areas  Association. That 
means that the measurement of distance between the private area  and the 
public area  is computed within the graphical habitat. Unless a graphical 
object is explicitly named as the context for distance measurements, the 
assumption is made that the last explicitly named subject should serve this role. 
The necessity of naming (tacitly or exp licitly) a graphical context for 
measurements arises from the generality of the HERMES language, which can be 
referring to any object in the database, rather than to the content of a unique 
construction area as assumed in JANUS and PHIDIAS. 
      Tacit and Explicit U nderstanding in Computer Support                                       297 
   Finally, in th e definition of problem areas  the deictic variable those 
items refers to the most recently enumerated items, namely the public areas  
that are enumerated for each private area  and that satisfy the Filter condition. 
During the testing of the Filter condition , the successful enumerated items are 
stored on a special list that can be referenced by the special deictic variable 
“those items .” Thus, the with those items phrase following the Filter 
phrase retrieves the list of public areas  that are too near  a given private 
area and adds them to the result list of the critic following that private area  
and indented under it.  
Now that the computational heart of the privacy check  critic has been defined, 
the critic can be assembled. First, a privacy message is defined to be displayed in 
the case that no problem areas are found for a given habitat. This is simply a 
Character node with the contents:  
“Public and private areas are sep arated.”  
This node can be named privacy message  or it can be linked to the privacy 
check critic itself. If it is named, the critic is defined as:  
name with either name of problem areas or privacy message  
If it is linked with a link of type message , then the critic is defined as:  
name with either name of problem areas or message of this 
(expression)  
In the latter case, the reference to the privacy message  is replaced by a 
computation, message of this (expression) , using the deictic variable 
this. The variabl e this (expression)  refers to the current object itself, so 
message of this (expression)  follows the message  link from the 
definition of this critic to the Character node whose content is the required 
message. Again, the use of parentheses signals the need  for some explicit reflection 
by the reader.  
The privacy check  critic uses the implicit if / then construction, either / 
or, in which the first phrase is used if it produces any results, otherwise the second 
phrase (in this case, simply displaying the mess age) is used. The principal work 
done by the definition of privacy check  is to display the names of graphical 
objects, rather than displaying them as graphics. Privacy check  is a Computed 
Association that is applied to a DataList of one or more habitats. S o it first displays 
the name to the habitat to which it is being applied, then (indented under that name, 
because of the with conjunction) it computes the list of problem areas  of 
that habitat and displays the names of all the items in the resultant list ( including 
      Tacit and Explicit U nderstanding in Computer Support                                       298 
  the names of the public areas  that are indented in the list under the private 
areas). If the resultant list was empty for a given habitat, the privacy 
message  is displayed instead.  
In the scenario, a variation on privacy check  named privacy displ ay 
was defined:  
name and privacy ratings of problem areas  
This critic displays the privacy ratings  as well as the names of all items in 
the list computed by the problem areas  Association.  
Recall from Chapter 3 that the lunar habitat designers eventually s ettled on a 
concept of privacy gradient  in the transcribed session. That meant that they wanted 
the arrangement of the habitat to change gradually from private areas to public 
areas. To operationalize this notion, one could introduce a test to see if any two 
areas that are near each other diffe r by more than a value of, say, plus or minus 
two. This introduces explicit arithmetic computations into the definitions of a 
critic. It also introduces a complicated comparison of each habitat part with all the 
other parts of the habitat. The following se t of definitions can be used to compute 
habitat parts that are incompatible in this sense of a privacy gradient.  
In the Chapter 9 scenario, the designers ended up with a critic called privacy 
gradient catalog . It goes through all habitats in the database, selecting those 
for which privacy ratings  links are attached to some parts. For those 
habitats, it displays their name and an analysis of how they meet the defined 
privacy gradient considerations:  
name with privacy gradient critique of habitats that have 
parts that have privacy ratings  
For each habitat that has privacy ratings, the privacy gradient critique  
is displayed. This is similar to the privacy display , above, in that it computes 
problem parts  using a privacy gradient listing  Association, or 
else displays a privacy gradient message . Here are the definitions to 
handle this:  
privacy gradient critique: either privacy gradient listing 
or privacy gradient message  
privacy gradient listing: name and privacy ratings of parts 
that have privacy ratings with the ir problem parts  
privacy gradient message: “The parts of this design are 
arranged along a privacy gradient.”  
      Tacit and Explicit U nderstanding in Computer Support                                       299 
  The privacy gradient listing  Association iterates through the parts of 
a habitat and for each part lists (indented) their problem parts . The defini tion 
of problem parts  is the tricky part. It uses three further definitions: too 
near, other parts , and are incompatible . The Measure, too near , 
is the same as it was in the privacy check critic , except that in the current 
perspective it has been modified from 5 feet to 3 feet:  
problem parts: name and privacy ratings of other parts that 
are too near that (last subject) and that are 
incompatible  
too near: closest distance is less than 3 feet  
other parts: parts of inverse parts that do not equal that 
(last subject) 
are incompatible: have privacy ratings that are more than 
privacy ratings of that (last subject) + 2 or are less 
than privacy ratings of that (last subject) -2 
The definition of other parts  requires some explanation. Within the 
privacy gradient lis ting expression, the Association problem 
parts must be applied to parts (of a habitat). The definition of problem 
parts centers on the definition of other parts . However, what is wanted is 
“other parts” of the habitat, not other parts of the selected part of the habitat, which 
is what would result from the application of problem parts  to parts. 
Therefore, within the definition of other parts , the computation must get back 
to the habitat by tracing backwards the part link between the habitat and its part. 
This is accomplished by the construction, inverse parts . Once the 
computation is back at the habitat, it can find the other parts by navigating all the 
parts (i.e., graphical content) links of the habitat. Of course, the computation of 
“other parts” should e xclude the part from which the computation began in order 
to avoid comparing that part with itself. This is accomplished with the Filter, that 
do not equal that (last subject) , in which the deictic variable 
that (last subject) refers to the last “subject” of application, namely the 
original part iterated in the privacy gradient listing  expression.  
The definition of the Filter, are incompatible , uses the same that (last 
subject) variable in order to compare each of the other parts  with the 
original part. This Filter also introduces explicit arithmetic in order to judge 
whether the privacy ratings  of these two parts differ by more than 2 on the 
privacy scale. This comparison completes the operationalization of the idea of a 
privacy gradient as it occurred in t he lunar habitat design transcript.  
      Tacit and Explicit U nderstanding in Computer Support                                       300 
  The definition of privacy gradient catalog  with all its preliminary 
definitions is a relatively formidable task. If one undertakes figuring it out from 
scratch, it might well seem that the task is easier to do in a tradi tional programming 
language. This seems especially true to people who are experienced in 
programming. It may well be that such a task pushes the HERMES language to near 
its limits. On the other hand, a design environment built on the HERMES substrate 
might support reuse and modification sufficiently to make the HERMES alternative 
preferable. First, much of the defining could have been done in the seeded set of 
language definitions, providing a well-thought-out collection of building blocks 
for complex tasks involving privacy. If this was not available in the original s eed, 
a reseeding process could take place when the privacy issue is raised as an 
important concern. Then an experienced programmer or a HERMES local developer 
could step in and provide a set of privacy -related definitions for everyone to use.  
As stated at  the outset of this chapter, the HERMES language has been developed 
to push its approach to supporting a mix of tacit and explicit understanding as far 
as possible and to explore its limits. The privacy gradient critique  
expression provides an important te st of these limits. On the one hand, it shows 
that the task that appeared extremely challenging back in Chapter 3 can in fact be 
accomplished using the HERMES language. On the other hand, it shows that such a 
task may strain the limits of the language. The  limits of the language are explored 
further by examples in Appendix B. More thorough experience will have to await 
the building of robust design environments on the HERMES substrate and their use 
by a community of designers.  
 
Conclusion  
 
 
 
 
 
 “I propose that men and women be returned to work  
 as controllers of machines, and that the control of people  
 by machines be curtailed. I propose, further, that the effects  
 of changes in technology and organization on life  patterns  
 be taken into careful consideration, and that the changes  
 be withheld or introduced on the basis of this consideration.”  
    Kurt Vonnegut, Jr.  
    Player Piano  
    (1952, p. 285)  
   
 
 
CHAPTER 11. CONTRIBUTIONS  
The topic of this dissertation has been the problem of providing computer support 
for cooperative design given the nature of tacit and explicit understanding. But at 
a meta-level, an important theme has been the role of theory in software design. 
Often, work in cogn itive science and artificial intelligence proceeds with little 
reference to philosophy, which is given lip service as one constituent of these 
interdisciplinary endeav ors. Of course, preconceptions abound in such work, but 
they are either treated as self -evident common sense or addressed through 
discussions of individual concepts whose inner coherence remains outside the 
investigation.  
This dissertation is an attempt to take theory seriously in computer science. Rather 
than first creating a software artifac t whose theory is at best only tacitly available 
retrospectively,26 and then subjecting the artifact to controlled user testing to 
determine its effectiveness, the approach followed here is to formulate a set of 
explicit theoretical principles to motivate an approach to computer support of 
design and then to present a pac kage of prototyped functionality to illustrate that 
approach. Together, the theory and the examples are meant to provide cogent 
arguments for the deliberation of central issues in software design of systems to 
support innovative, collaborative design work in exploratory domains.  
 
26Carroll and associates have made a case for considering artifacts as themselves 
implicit expressions of theories, as though guiding philosophies were 
unnecessary. This case has been made specifically in terms of software artifacts 
in the realm of human -computer interaction, and has even been related to 
hermeneutics (Carroll & Campbell, 1989; Carroll & Kellogg, 1989). While they 
persuasively point o ut problems with the traditional assumptions about the 
relation of psychological theory to design practice, they overlook the spiral 
character of understanding, in particular the guiding role of (often tacit) 
philosophical beliefs and conceptual frameworks . 
      Tacit and Explicit U nderstanding in Computer Support                                       303 
  Of course, several preconceptions have been at work here, too. However, the major 
assumptions have been systematically reflected upon in the process and explicated 
or modified as need be. It has been assumed, for instance, that soft ware to support 
professional designers should be based on an understanding of the structure of their 
work processes. As a guiding idea, the design process was viewed (or pre -viewed) 
as a process of interpretation (Chapter 1). Two approaches were then taken  to 
explore this work process: one by looking at some of the best available descriptions 
of the way designers work (by Alexander, Rittel, and Schön in Chapter 2), and the 
other by looking at a concrete example of designers working (on lunar habitat 
design in Chapter 3). To make this theory even more explicit and general, it was 
then put into the framework of a philosophy (Heidegger’s hermeneutics in Chapter 
4). An explicit theory of computer support for interpretation in design was built on 
top of the resul ts of the preceding investigations (Chapter 5 and 6). The theory 
developed in this way was then used to evaluate related software systems meant to 
support design (Chapter 7). Finally, the theory served to motivate and justify 
design decisions in the H ERMES software (Chapters 8, 9, and 10).  
While this approach stresses theory, it does not ignore the need for empirical 
grounding or iterative testing. The design methodologies reviewed all grew out of 
either reflection on professional practice or consideration of experimental findings. 
The study of lunar habitat design pursued as part of the dissertation took on the 
flavor of participatory design (Ehn, 1988; Greenbaum & Kyng, 1991) by having 
the software designers and the design professionals working together on  a lunar 
habitat design, and by involving the two groups in dialogue about the design work 
and about possibilities for computer -based support of this work. Although it was 
never reflected in the Chapter 3 transcripts, the lunar habitat designers have been 
involved in on -going evaluation of the H ERMES system and its functionality as part 
of their role as corporate sponsors of the funded research. In addition, the design 
of HERMES is a response to empirical experience with the related design 
environments on w hich it is based, as well as on a series of programming 
walkthroughs to evaluate the H ERMES language design (reported in Appendix A).  
Evaluation and refinement of the Lunar Habitat Design Environment ( LHDE) and 
PHIDIAS II built on top of the H ERMES substrate are expected to continue 
indefinitely. Clearly, the greatest need for future work is to build a robust design 
environment that exercises all of the functionality of the HERMES substrate and to 
gain experience in the utility of this functionality throug h use by professional 
designers. Unfortunately, that is beyond the scope of the present effort. For one 
thing, it will involve identifying real -world projects in which a system like LHDE 
makes commercial sense in order to get professionals to invest signif icant time in 
using preliminary versions. The support of lunar habitat design has served as a 
fruitful application domain in developing HERMES, but a specific project must now 
      Tacit and Explicit U nderstanding in Computer Support                                       304 
  provide a practical context for further participatory development and workplace 
evaluation.  
It is useful to view the unfolding of this dissertation as a hermeneutic process, in 
which a vague preconception of interpretation in design becomes increasingly 
clearer through precisely the kind of interpretive process that has been analyzed in 
the dissertation. The concept of interpretation has been elaborated through an 
investigation of the role of interpretation in design. The guiding perspective was 
the intuition that interpretation is the central category for founding a theory of 
computer  support. This perspective was tied through a process of reflection to its 
explicit roots in Heidegger's philosophy, but also to the almost forgotten role of 
interpretation in the related systems that HERMES grew out of. In a sense, the 
dissertation embodi es a moment of reflection in which the effort to build systems 
of computer support ran up against the limits of multi -faceted, domain -oriented, 
knowledge -based systems; made explicit the role of interpretation in design; and 
then, using this, proposed a sy stem that integrates the facets in a hypermedia 
substrate, extends the notion of domain -orientation with perspectives , and 
uncovers the basis of explicit computer knowledge representations in the 
expressing of tacit human preunderstanding in language . 
In looking back over what has been accomplished in this dissertation, it is clear 
that no final answers have been given. The analysis of interpretation remains 
unclear and incomplete in many ways. The theory of computer support is no more 
than a beginning in a n attempt to provide rationale for a new direction in artificial 
intelligence. The design of HERMES is suggestive of promising functionality, but 
this promise remains largely untested. Nevertheless, whatever the limits of this 
work, it does seem to have ma de significant contributions on three primary levels: 
on a philosophical level (11.1), on a theoretical level (11.2), and on a system 
building level (11.3).  
11.1 Contributions to a Philosophy of 
Interpretation  
At least since Dreyfus (1966; 1972; & Dreyfus, 1986), the relevance of 
Heidegger’s philosophy to AI has been debated. Unfortunately, most of the 
discussion by computer scientists has relied on secondary sources, especially pre -
publication drafts of Dreyfus ’ (1991) commentary on Heidegger. So one 
contribution of this dissertation has been to return to the original text of Heidegger 
(1927) and to systematically apply that text to the context of computer support for 
      Tacit and Explicit U nderstanding in Computer Support                                       305 
  interpretation in design. The result has bee n an analysis of interpretation  that is 
frequently more detailed and rigorous than alternative presentations. This 
represents a contribution to Heideggerian scholarship as such, not just from a 
computer science perspective.  
Of course, according to the phil osophy there is no “correct” interpretation of a text 
unrelated to a background of concerns. The confrontation of the Heideggerian text 
with the problematic of design and computer support for design had important 
consequences. Examples from design methodol ogy and from lunar habitat design 
provided not only a concreteness to Heidegger’s abstractions, but a more realistic 
context than Heidegger’s own craft -oriented glimpses of the lonely carpenter 
absorbed in his hammering. Design shifted the emphasis to coll aborative work. It 
also moved (thanks largely to Schön’s insights) from use of the physical artifact to 
the more conceptual design of artifacts. In particular, this brought to the fore the 
role of discovery over that of laying out what was implicitly discl osed. This 
clarified and extended the analysis of interpretation, removing certain ambiguities 
that Heidegger glossed over.  
Perhaps most importantly, the effort to apply Heidegger’s philosophy to computer 
system building not only forced a precision of concept but resulted in the 
operationalizing of many of the ideas. This is, of course, a common benefit to 
philosophy of mind when it is applied in AI. In this case, the result was a computer 
model of human interpretation as situated, perspectival, and linguis tic. However, 
in addition to the model, there is an extensive recognition of the limits of the model 
and the need to involve people in the operation of the model. These limits are 
shown to be consequences of the Heideggerian analysis. So philosophy benefit ed 
from its meeting with computer science.  
11.2 Contributions to a Theory of Computer 
Support  
The central contribution was to identify the key concept for a theory of computer 
support: interpretation. Although Winograd & Flores (1986), for instance, talked  a 
lot about interpretation, they ranged across Heidegger’s (1927) framework and 
focused on its critique of technical rationality. Ironically, their proposed software 
example, the COORDINATOR  program, suffered from a lack of respect for the 
importance of i nterpretative control by the users. They failed to take seriously the 
fact that there is no objective structure to a domain and that people should be 
supported in defining their own analyses, interpretations, and terminologies from 
      Tacit and Explicit U nderstanding in Computer Support                                       306 
  their own perspectives. Support for interpretation is the ingredient missing from 
most traditional AI programs. This dissertation contributes the antidote: a 
recognition of the central role of interpretation and the impossibility of fully 
automating it . It is difficult to convey the potential importance of this contribution; 
that is why so many pages of the dissertation have been devoted to this theme.  
The proposed theory of computer support is built squarely on the analysis of 
interpretation. This gives the theory a coherence and  consistency missing from 
other theoretical frameworks in computer science (other than those based on 
strictly formal logical grounds). It demonstrates how philosophy (again, other than 
logic) can be put in the service of computer science.  
Knowledge -based system design inevitably raises the question of the nature of 
knowledge. Some contributions have been made here. First, the varieties of 
knowledge or information have been categorized  in terms of their origins in 
various phases of the process of interpreta tion. This includes not only tacit and 
explicit understanding, but also shared understanding and captured computer 
representations. Second, the idea of domain knowledge has been critiqued. Not 
only does knowledge in a design domain change as the related te chnologies and 
styles change and as the expertise of the field matures and grows, but every 
designer and every design team have their own domain knowledge. It is not simply 
that they each have different pieces of an underlying knowledge. Rather, to know 
is to know from a perspective, so there is no objective body of domain knowledge 
independent of what people know in their own ways , within their many 
perspectives. Third, the role of language in expressing knowledge has been 
emphasized. The emergence of inte rpersonal or operationalized knowledge from 
tacit experience takes place through discourse and assertion  within situated 
interpretation. Correspondingly, an end -user language has an important role to play 
in computer support.  
11.3 Contributions to a System  for Innovative 
Design  
The effort to illustrate the functionality called for by the theory resulted in three 
major contributions to building computer support for innovative design: (a) a 
hypermedia knowledge representation substrate, incorporating: (b) a s ystem of 
perspectives and (c) an end -user language. The design of each of these features has 
been thought through, both in terms of the functionality required by the theory and 
in terms of their usability in a practical computer system for design professio nals. 
      Tacit and Explicit U nderstanding in Computer Support                                       307 
  Each has also been prototyped in executable code and subjected to testing to 
confirm the implementability of the ideas. Various versions of these features, along 
with auxiliary functionality have also been incorporated in a series of design 
environme nts that have been shown to lunar habitat designers for feedback.  
(a) The hypermedia substrate  incorporates the power of the fine -grained hypertext 
in the original PHIDIAS system, provides an efficient and scalable object -oriented 
database for persistence,  incorporates multi -media nodes, and integrates the 
perspectives and language into the fundamental node and link structure. This 
hypermedia offers an extremely powerful and flexible knowledge representation 
system, whose control by the user is limited prim arily by the lack of a fuller user 
interface. Adaptability by the user —or plasticity of representation —is critical 
according to the theory. The HERMES hypermedia contributes an example of a 
substrate for supporting such adaptability.  
(b) The perspectives m echanism  is a contribution to Computer Supported 
Cooperative Work. It allows individuals to organize their own versions of 
knowledge representations and to share them. This provides a tool for supporting 
the evolution of knowledge by starting with systemat ically organized domains and 
allowing users to inherit and modify these and to organize meaningful new 
domains. The virtual copying approach is an inherently efficient mechanism, 
which encourages consistency by eliminating unnecessary duplication of 
representations in multiple copies.  
(c) The HERMES language is a contribution to end -user programming languages 
and programmable design environments. It suggests ways of reducing the 
programming doctrine that users have to learn or keep in mind. Much of the 
traditional programming language doctrine is suppressed by keeping the 
corresponding features tacit in the HERMES language. Also, the appearance of 
expressions in the language supports tacit understanding by making heavy use of 
user-defined domain terminology and by following several syntactic conventions 
of natural language. At the same time, when the computational structure of an 
expression must be made more explicit to be understood or modified, this can be 
done to some extent through interface displays and to some extent by exploratory 
execution. A programming language paradigm that was implicit in PHIDIAS’ query 
language has been pushed forward, extended, and modified to the point of a 
powerful end -user language that can play key roles in a system to suppor t 
interpretation.  
 
Computer technology can contribute to human emancipation. By providing 
computationally active media of external memory, it can significantly extend 
cognitive capabilities within an increasingly complex world. However, that 
      Tacit and Explicit U nderstanding in Computer Support                                       308 
  requires a peo ple-centered approach in which machine computations are at the 
service of human judgments and interpretation. Mainstream software approaches 
have developed within a social context dominated by the interests of military, 
government, and multinational corpor ations, resulting in computer applications 
that replace people or that dictate how they think and work. This dissertation has 
tried to present design rationale to oppose the bureaucratic interests, a theory to 
guide people -centered software development, an d example mechanisms for giving 
people innovative, shared control over software computations.  
 
 
BIBLIOGRAPHY  
Abelson H, Sussman G (1985) Structure and Interpretation of Computer 
Programs . Cambridge: MIT Press.  
Adorno TW (1964). Jargon der Eigentlichkeit: Zur deutschen Ideologie.  [The 
Jargon of Authenticity]. Frankfurt am Main: Suhrkamp.  
Adorno TW (1966). Negative Dialektik  [Negative Dialectics]. Frankfurt am 
Main: Suhrkamp.  
Alexander C (1964) Notes on the Synthe sis of Form . Cambridge: Harvard 
University Press.  
Alexander C (1971) The State of the Art in Design Methods. In Cross N (1984). 
309-316. 
Alexander C, Ishikawa S, Silverstein M, Jacobson M, Fiksdahl -King I, Angel S 
(1977) A Pattern Language: Towns, Building s, Construction . New York: 
Oxford University Press.  
Alexander C, Poyner B (1966) The Atoms of Environmental Structure. In Cross 
N (1984). 123 -133. 
Backus J (1978) Can Programming be Liberated from the von Neumann Style? A 
Functional Style and Its Algebra o f Programs. Communications of the ACM. 
21. (8). 613-641. 
Bell B, Citrin W, Lewis C, Rieman J, Weaver R, Wilde N, Zorn B (1992).The 
Programming Walkthrough: A Structured Method for Assessing the 
Writability of Programming Languages. Technical Report CU -CS-577-92 
January 1992. Department of Computer Science. University of Colorado.  
Bernstein B (1992) Euclid: Supporting Collaborative Argumentation with 
Hypertext. Technical Report CU -CS-596-92 January 1992. Department of 
Computer Science. University of Colorado . 
Bluth BJ (1984) Space Station/Antarctic Analogs . Washington, D.C.: NASA.  
Bluth BJ (1986) Lunar Settlements —A Socio-economic Outlook. 37th Congress 
of the International Astronautical Federation , Innsbruck, Austria, October 
4-11. Oxford: Persimmon Press. 
Boborow DG, Goldstein IP (1980a) An Experimental Description -Based 
Programming Environment: Four Reports.  Technical Report CSL -81-3. 
Palo Alto, CA: Xerox Palo Alto Research Center.  
      Tacit and Explicit U nderstanding in Computer Support                                       310 
  Boborow DG, Goldstein IP (1980b) Representing Design Alternatives. I n 
Boborow & Goldstein 1980a. 19 -29. 
Boborow DG, Winograd T (1977) An Overview of KRL, A Knowledge 
Representation Language. Cognitive  Science 1 (1), 3-46. In Brachman & 
Levesque (1985).  
Boeing Aerospace Company (1983) Space Station/Nuclear Submarine Analogs . 
Granada Hills, CA: National Behavior Systems.  
Boland RJ Jr., Maheshwari AK, Te’eni D, Schwartz DG, Tenkasi RV (1992) 
Sharing Perspectives in Distributed Decision Making. CSCW ‘92 
Proceedings . 
Bourdieu P (1977) Outline of a Theory of Practice . Oxford: Oxf ord University 
Press. 
Bourdieu P (1991) The Political Ontology of Martin Heidegger . Stanford: 
Stanford University Press.  
Brachman R, Levesque H (1985) Readings in Knowledge Representation.  San 
Mateo: Morgan Kaufmann.  
Buchanan BG, Shortliffe EH (1984) Human  Engineering of Medical Expert 
Systems. In Buchanan BG, Shortliffe EH (Eds.) (1984) Rule-Based Expert 
Systems: The MYCIN Experiments of the Stanford Heuristic Programming 
Project. Reading, MA: Addison -Wesley. 599 -612. 
Budde R, Züllighoven H (1990) Software-Werkzeuge in einer 
Programmierwerkstatt: Ansätze eines hermeneutisch fundierten Werkzeug - 
und Maschinenbegriffs . [Software Tools in a Programming Workshop: 
Approaches to an Hermeneutically -based Concept of Tools and Machines]. 
München: Oldenbourg Verlag.  
Bush V (1945) As We May Think. Atlantic Monthly.  176 (1), 101 -108. Reprinted 
in Greif I (1988) Computer -Supported Cooperative Work . San Mateo, CA: 
Morgan Kaufmann.  
Cardelli L, Wenger P (1985) On Understanding Types, Data Abstraction, and 
Polymorphism. ACM Computing Surveys. 17.  (7). 471-522. 
Carroll JM, Campbell RL (1989) Artifacts as Psychological Theories: The Case 
of Human -Computer Interaction. Behavior and Inform ation Technology . 
Vol. 8, no. 4, 247 -256. 
Carroll JM & Kellogg WA (1989). Artifact as theory -nexus: hermeneutics meets 
theory-based design, Proceedings of the Conference of Human Factors in 
Computing Systems , Austin, 7 -14. 
Compton WD, Benson CD (1983) Living and Working in Space: A History of 
Skylab. Washington, DC: NASA.  
Conklin J, Begeman M (1988) gIBIS: A Hypertext Tool for Exploratory Policy 
Discussion. Proceedings of the Conference on Computer Supported 
Cooperative Work . New York: ACM. 140 -152. 
      Tacit and Explicit U nderstanding in Computer Support                                       311 
  Coyne R (1991). Inconspicuous Architecture, Gadamer Action & Reason: 
Conference Proceedings . Australia: University of Sydney. 62 -70. 
Coyne R, Snodgrass A (1991) What Is the Philosophical Basis of AI in Design? 
Working paper. Faculty of Architecture, University of  Sydney. 
Cross N (1984) Developments in Design Methodology . New York: Wiley.  
Dayton T, et al. (1993) Skills Needed by User -centered Design Practitioners in 
Real Software Development Environments: Report on the CHI ‘92 
Workshop. SIGCHI Bulletin . 25 (3) 16-31. 
Design Edge (1990) Initial Lunar Habitat Construction Shack . Design control 
specification. Houston, TX.  
Descartes R (1641) Meditations of First Philosophy . Indianapolis: Hackett. 1979  
Donald M (1991) Origins of the Modern Mind: Three Stages in the Evolu tion of 
Culture and Cognition . Cambridge: Harvard University Press.  
Dreyfus H (1966) Alchemy and Artificial Intelligence.  Rand paper P3244. The 
Rand Corporation.  
Dreyfus H (1967) Phenomenology and Artificial Intelligence. In Edie J (ed.) 
(1967) Phenomenolo gy in America . Chicago: Quadrangle. 31 -47. 
Dreyfus H (1972) What Computers Cannot Do . New York: Harper and Row.  
Dreyfus H (ed.) (1982) Husserl, Intentionality, and Cognitive Science . 
Cambridge: MIT Press.  
Dreyfus H (1985) Holism and Hermeneutics. In Hollinger R (Ed.) (1985) 
Hermeneutics and Praxis . Notre Dame, IN: University of Notre Dame Press. 
227-247. 
Dreyfus H (1990) Heidegger’s History of the Being of Equiptment . In Dreyfus H, 
Hall H (eds.) (1991) Heidegger: A Critical Reader . Oxford: Basil 
Blackwell. 173 -185. 
Dreyfus H (1991) Being-in-the-World: A Commentary on Heidegger's Being and 
Time, Division I . Cambridge: MIT Press.  
Dreyfus H, Dreyfus S (1986) Mind Over Machine . New York: Free Press.  
Ehn P (1988 ) Work-Oriented Design of Computer Artifacts . Stockholm: 
Arbetslivscentrum.  
Eichold A (1992) Lunar Base Planning Criteria. NEA grant final report. 
Washington, DC: NEA.  
Eisenberg M (1992). SchemePaint: A Programmable Application for Graphics. 
Technical Repo rt CU-CS-587-92. Computer Science Department, 
University of Colorado at Boulder.  
Eisenberg M, Fischer G (1992) Programmable Design Environments and Design 
Rationale. AAAI’92 Workshop on Design Rationale Capture and Use. San 
Jose, CA. July 15, 1992. 81 -90. 
Engelbart D (1963) A Conceptual Framework for the Augmentation of Man's 
Intellect. In Howerton, P (Ed.) (1963) Vistas of Information Handling . (Vol. 
1). Washington, DC: Spartan Books. Reprinted in Greif I (Ed.) (1988) 
      Tacit and Explicit U nderstanding in Computer Support                                       312 
  Computer -Supported Cooperative Work. San Mateo, CA: Morgan 
Kaufmann.  
Ericsson KA, Simon HA (1984) Protocol Analysis: Verbal Reports as Data . 
Cambridge: MIT Press.  
Fischer G (1989) Creativity Enhancing Design Environments. Proceedings of the 
International Conference “Modeling Creativity and Kn owledge-Based 
Creative Design .” Heron Island, Australia. 127 -132. 
Fischer G (1991) Supporting Learning on Demand with Design Environments. 
Proceedings of the International Conference on the Learning Sciences 
August 1991 . Evanston, IL. 127 -132. 
Fischer G, G irgensohn A (1990) End -User Modifiability in Design 
Environments. Human Factors in Computing Systems, CHI '90 Conference 
Proceedings (Seattle, WA). New York: ACM.  
Fischer G, Grudin J, Lemke A, McCall R, Ostwald J, Reeves B, Shipman F 
(1991a). Supporting In direct, Collaborative Design with Integrated 
Knowledge -Based Design Environments. Submitted to Human-Computer 
Interaction . 
Fischer G, Lemke A, McCall R, Morch A (1991b) Making Argumentation Serve 
Design. Human-Computer Interaction (Special Issue on Design Rationale). 
6, (3 & 4), 393 -419. 
Fischer G, McCall R, Morch A (1989) Janus: Integrating Hypertext with a 
Knowledge -based Design Environment. Proceedings of Hypertext '89 . 
Pittsburgh, PA: ACM, 105 -117. 
Fischer G, McCall R, Ostwald J, Reeves B, Shipman F (19 93c) Seeding, 
Evolutionary Growth and Reseeding: Supporting Incremental Development 
of Designs and Design Environments. Submitted to AAAI’93. 
Fischer G, Nakakoji K (1992) Beyond the Macho Approach of Artificial 
Intelligence: Empower Human Designers —Do Not Replace Them. 
Knowledge -Based Systems Journal.  5, (1), 15-30.  
Fischer G, Nakakoji K, Ostwald J, Stahl, G, Sumner T (1993a) Embedding 
Computer -Based Critics in the Contexts of Design. Proceedings of InterCHI 
‘93. Conference on Human Factors in Computing Sy stems. Amsterdam. 
April 1993. 157 -164. 
Fischer G, Nakakoji K, Ostwald J, Stahl, G, Sumner T (1993b) Embedding 
Critics in Design Environments. The Knowledge Engineering Review , 
Special Issue on Expert Critiquing. Fall 1993.  
Fitzgerald F, Rashid R (1986) The  Integration of Virtual Memory Management 
and Interprocess Communication in Accent. ACM Transactions on 
Computer Systems , 4, (2), 147.  
Floyd C, Züllighoven H, Budde R, Keil -Slawik (1992) Software Development 
and Reality Construction . Heidelberg: Springer Verlag.  
      Tacit and Explicit U nderstanding in Computer Support                                       313 
  Foley J, van Dam A, Feiner S, Hughes J (1990) Computer Graphics: Principles 
and Practice.  Reading, MA: Addison -Wesley. 
Fodor J (1981) Methodological Solipsism Considered as a Research Strategy in 
Cognitive Psychology. In Haugland (1981). 3 07-338. 
Freud S (1917) A General Introduction to Psychoanalysis . New York: 
Washington Square Press. 1952.  
Gadamer H -G (1960) Wahrheit und Methode . Tübingen: Mohr. Translation: 
Gadamer H -G (1988) Truth and Method. New York: Crossroad.  
Gadamer HG (1966) Die Universalität des hermeneutischen Problems [The 
universality of the hermeneutic problem]. In Gadamer HG (1967) Kleine 
Schriften I Philosophie Hermeneutic . Tübingen: Mohr. 101 -112. 
Gadamer HG (1967) Rhetorik, Hermeneutik und Ideologiekritik [Rhetoric, 
Hermeneutics and Ideology Critique]. In Gadamer HG (1967) Kleine 
Schriften I Philosophie Hermeneutic . Tübingen: Mohr. 113 -130. 
Girgensohn A (1992) End-User Modifiability in Knowledge -Based Design 
Environments.  Ph.D. dissertation. Department of Computer Science.  
University of Colorado at Boulder.  
Goldstein IP, Boborow DG (1980) Descriptions for a Programming 
Environment. Proceedings of the First Annual Conference of the National 
Association for Artificial Intelligence , Stanford, CA. 1 -6. 
Greenbaum J, Kyng M (1991) Design at Work: Cooperative Design of Computer 
Systems. Hillsdale, NJ: Lawrence Erlbaum.  
Greif I (Ed.) (1988) Computer -Supported Cooperative Work . San Mateo, CA: 
Morgan Kaufmann.  
Grice HP (1975) Logic and Conversation. In Cole P,  Morgan J (1975) Syntax and 
Semantics 3: Speech Acts . New York: Academic Press. 41 -58. 
Habermas J (1967) Zur Logik der Sozialwissenschaften [On the Logic of the 
Social Sciences]. Philosophiphische Rundschau . Beiheft 5, February 1967. 
Habermas J (1968) Erkenntnis und Interesse  [Knowledge and human interests]. 
Frankfurt a. M.: Suhrkamp Verlag.  
Habermas J (1985) Der philosophische Diskurs der Moderne: Zwölf Vorlesungen  
[The Philosophical Discourse of Modernity]. Frankfurt am Main: Suhrkamp.  
Halasz F (1988) Ref lections on Notecards: Seven Issues for the Next Generation 
of Hypermedia Systems. Communications of the ACM . Vol. 31, No. 7. 836 -
852. 
Harnad S (1993) Grounding, Situatedness, and Meaning. In Proceedings of the 
Fifteenth Annual Conference of the Cognitive Science Society . Boulder, CO. 
169-174. 
Haugland J (Ed.) (1981) Mind Design . Cambridge: MIT Press.  
Hegel GWF (1807) Phänomenologie des Geistes . Translation: Hegel GWF 
(1967) Phenomenology of Mind . New York: Harper & Row.  
      Tacit and Explicit U nderstanding in Computer Support                                       314 
  Hegel GWF (1833) Grundlinien der Phi losophie des Rechts  [Principles of the 
philosophy of right]. Leipzig.  
Heidegger M (1927) Sein und Zeit . Tuebingen: Niemeyer. Translation: 
Heidegger M (1962) Being and Time . New York: Harper & Row.  
Heidegger M (1947) Brief Über den “Humanismus” [Letter on H umanism]. In 
Heidegger M (1967) Wegmarken . Frankfurt a.M.: Klostermann.  
Heidegger M (1950) Ursprung des Kunstwerks [The origin of the work of art]. In 
Heidegger M (1950) Holzwege . Frankfurt a.M.: Klostermann.  
Heidegger M (1951) Erläuterungen zu Hölderlins Dichtung. [Commentary on 
Holderlin’s Poetry] Frankfurt a.M.: Klostermann.  
Heidegger M (1953). Wissenschaft und Besinnung [Science and reflection]. In 
Heidegger M (1954) Vorträge und Aufsätze . Pfullingen: Neske.  
Heidegger, M. (1971) Poetry, Language, Though t. Trans. A. Hoftadter. New 
York: Harper & Row.  
Heidegger M (1975) Der Grundprobleme der Phänomenologie  [Basic problems 
of phenomenology]. Gesamtausgabe  vol. 24. Frankfurt a.M.: Klostermann.  
Heidegger M (1979) Prolegomena zur Geschichte des Zeitbegriffs  [Introduction 
to the history of the concept of time]. Gesamtausgabe  vol. 20. Frankfurt 
a.M.: Klostermann.  
Hewitt C (1971) Description and Theoretical Analysis (Using Schemata) of 
PLANNER: A Language for Proving Theorems and Manipulating Models in a 
Robot. Ph.D. Thesis. June 1971. Reprinted in AI -TR-258 MIT-AI 
Laboratory, April 1972.  
Hinton G, Anderson J (1989) Parallel Models of Associative Memory . Hillsdale, 
NJ: Lawrence Erlbaum.  
Hutchins E (1990) The Technology of Team Navigation. In Galegher P, Kraut R, 
Egido C (Eds.) (1990) Intellectual Teamwork . Hillsdale, NJ: Erlbaum. 191 -
220. 
Illich I (1973) Tools for Conviviality . New York: Harper & Row.  
Johnson JA, Nardi BA, Zarmer CL, Miller JR (1993) ACE: Building Interactive 
Graphical Applications. Communications of the ACM . 36 (4). 41-55. 
Kant I (1787) Kritik der reinen Vernunft . Translation: Kant I (1929) Critique of 
Pure Reason . New York: St. Martin's Press.  
Kazmierski M, Spangler D (1992) Lunatechs  II: A Kit of Parts for Lunar Habitat 
Design. Unpublished project report, College of Environmental Design, 
University of Colorado at Boulder.  
Kolodner J (1984) Retrieval and Organizational Strategies in Conceptual 
Memory. Hillsdale, NJ: Lawrence Erlbaum.  
Kuhn T (1962) The Structure of Scientific Revolutions . Chicago: University of 
Chicago Press.  
      Tacit and Explicit U nderstanding in Computer Support                                       315 
  Kunz W, Rittel H (1970) Issues as Elements of Information Systems. Working 
paper 131. Center for Planning and Development Research, University of 
California, Berkeley.  
Kunz W, Rittel H (1984) How to Know What is Known: Designing Crutches for 
Communication. In Dietschmann ,  HJ (Ed) (1984) Representation and 
Exchange of Knowledge as a Basis of Information Processes . North-
Holland: Elsevier. 51 -60. 
Lakoff G (1987) Women, Fire, and Dangerous Things . Chicago: Univ. of 
Chicago Press.  
Lee J (1990) SIBYL: A Tool for Managing Group Decision Rationale. Proc. 
CSCW. LA: ACM Press.  
Lee J, Lai K -Y (1991) What’s in Design Rationale? Human-Computer 
Interaction . 6. 251-280. 
Lefebvre H (1991) The Production of Space . Oxford: Blackwell.  
Liskov B, Snyder A, Atkinson R, Shaffert C (1977) Abstraction Mechanisms in 
CLU. Communications of the ACM. 20 . (8). 564-576. 
Marshall C, Halasz F, Rogers R, Jannsen W (1991) Aquanet: A  Hypertext Tool 
to Hold your Knowledge in Place. In Hypertext ‘91 . 261-275. 
Marx K (1844) Texte zu Methode und Praxis II . Germany: Rowohlt. 1966.  
Marx K (1867) Das Kapital . Hamburg: Meissner. Translation: Marx K (1977) 
Capital. New York: Vintage.  
Mead GH ( 1934) Mind, Self, and Society . Chicago: University of Chicago Press.  
Merriam-Webster (1991) Webster’s Ninth New Collegiate Dictionary . 
Springfield: Merriam -Webster. 
Merleau-Ponty M (1945) Phenomenologie de la Perception . Paris: Gallimard. 
Translation: Merl eau-Ponty M (1962) Phenomenology of Perception.  
London: Routledge & Kegan Paul.  
McCall R (1986) Issue -Serve Systems: A Descriptive Theory of Design. Design 
Methods and Theories . Vol.20, no. 3, 443 -458. 
McCall R (1987) PHIBIS: Procedurally Hierarchical Issu e-Based Information 
Systems. Proceedings of the Conference on Architecture at the International 
Congress on Planning and Design Theory . New York: American Society of 
Mechanical Engineers. 17 -22. 
McCall R (1989) Mikroplis: A Hypertext System for Design. Design Studies , 10 
(4), 228-238. 
McCall R (1991) PHI: A Conceptual Foundation for Design Hypermedia. Design 
Studies. 12 (1), 30 -41. 
McCall R, Bennett P, d'Oronzio P, Ostwald J, Shipman F, Wallace N (1990a) 
Phidias: Integrating CAD Graphics into Dynamic Hypert ext. In Rizk A, 
Streitz N, Andre J (eds) (1990) Hypertext: Concepts, Systems and 
Applications  (Proceedings of ECHT ‘90). Cambridge: Cambridge 
University Press. 152 -165. 
      Tacit and Explicit U nderstanding in Computer Support                                       316 
  McCall R, Morch A, Fischer G (1990b) Supporting Reflection -in-action in the 
Janus Desig n Environment. In Mitchell W, McCullough M, Purcell P (eds) 
(1990b) The Electronic Design Studio . Cambridge: MIT Press. 247 -260. 
McCall R, Schaab B, Schuler W, Mistrik I (1983) Mikroplis User Manual.  
Heidelberg.  
McCall R (1989/90) Development of a Design E nvironment Integrating Dynamic 
Hypertext with CAD. Funded proposal to Colorado Institute for Artificial 
Intelligence.  
McCall R (1990/91) Intelligent Hypertext as an Alternative to Expert Systems. 
Funded proposal to Colorado Institute for Artificial Intelli gence. 
McCall R (1991/92) Virtual Copies of Hypermedia Networks in a System for 
Design of Space -based Habitats. Funded proposal to Colorado Institute for 
Artificial Intelligence.  
McCall R (1992/93) Intelligent Hypermedia Graphics in the Design of Space -
based Habitats. Funded proposal to Colorado Advanced Software Institute.  
McCall R (1993/95) Computer -Supported Knowledge Capture for the Design of 
Space-based Habitats. Proposal to Colorado Advanced Software Institute.  
Minsky M (1985) The Society of Mind . New York: Simon and Schuster.  
Mittal S, Boborow DG, Kahn KM (1986) Virtual Copies At the Boundary 
Between Classes and Instances. OOPSLA ‘86 Proceedings . 159-166. 
Miyake N (1986) Constructive Interaction and the Iterative Process of 
Understanding. Cognitive Sc ience. 10. 151-177. 
Moore GT, Fieber JP, Moths JH, Paruleski KL (1991) Genesis Advanced Lunar 
Outpost II: A Progress Report. In Blackledge RC Redfield CL Seida SB 
(Eds.), Space—A Call for Action: Proceedings of the Tenth Annual 
International Space Developm ent Conference . San Diego, CA: Univelt, 55.  
Nakakoji K (1993) The Role of a Specification Component.  Ph.D. dissertation. 
Department of Computer Science. University of Colorado at Boulder.  
Nardi B, Miller J (1990) The Spreadsheet Interface: A Basis for End User 
Programming. Proceedings of Interact ‘90 . 977-983. 
NASA (1989) Space Station Freedom Man -Systems Integration Standards . 
NASA-STD-3000 Volume I. Revision A. December 14, 1989. NASA.  
NASA (1989) Space Station Freedom Man -Systems Integration Standards . 
NASA-STD-3000 Volume IV. Revision A. December 14, 1989. NASA.  
Nielsen J, Frehr I, Nymand NO (1991) Th e Learnability of HyperCard as an 
Object-oriented Programming System. Behavioral Information Technology. 
10 (2) 111-120. 
Nilsson N (1980) Principles of Artificial Intelligence . Palo Alto: Morgan 
Kaufmann.  
Nobel DF (1984) Forces of Production: A Social Hist ory of Industrial 
Automation . New York: Knopf.  
      Tacit and Explicit U nderstanding in Computer Support                                       317 
  Norman D (1993) Things That Make Us Smart . Reading, MA: Addison -Wesley. 
In preparation.  
Norman D, Draper S (1986) User Centered System Design: New Perspectives on 
Human-Computer Interaction.  Hillsdale, NJ: Law rence Erlbaum.  
Palmer R (1969) Hermeneutics: Interpretation Theory in Schliermacher, Dilthey, 
Heidegger and Gadamer . Evanston: Northwestern University Press.  
Papert S (1980) Mindstorms: Children, Computers, and Powerful Ideas . New 
York: Basic Books.  
Plato (348 BC) The Collected Dialogues of Plato . E Hamilton & H Cairns (Eds.). 
New York: Pantheon. 1961.  
Polanyi M (1962) Personal Knowledge.  London: Routledge & Kegan Paul.  
Putnam H (1967) The Nature of Mental States. In Block N (Ed.) (1980) Readings 
in Philoso phy of Psychology  (Vol. 1). Cambridge: Harvard University Press. 
First published as Psychological Predicates. In Capitan WH,. Merrill DD 
(Eds.) (1967) Art, Mind and Religion.  Pittsburgh: University of Pittsburgh 
Press. 
Putnam H (1988) Representation and Reality . Cambridge: MIT Press.  
Quillian MR (1967) Word Concepts: A Theory and Simulation of Some Basic 
Semantic Capabilities. Behavioral Science  12, 410-430. In Brachman & 
Levesque (1985).  
Raybeck D (1991) Proxemics and Privacy: Managing  the Problems of Life in 
Confined Settings. In Harrison AA, Clearwater YA, McKay CP (Eds.) 
(1991) From Antarctica to Outer Space: Life in Isolation and Confinement.  
New York: Springer Verlag. 317 -330.  
Redmiles D (1992) From Programming Tasks to Solutions —Bridging the Gap 
Through the Explanation of Examples.  Ph.D. dissertation. Department of 
Computer Science. University of Colorado at Boulder.  
Reeves B (1993) The Role of Embedded Communication and Embedded History 
in Collaborative Design.  Ph.D. dissertation . Department of Computer 
Science. University of Colorado at Boulder.  
Resnick L (1991) Shared Cognition: Thinking as Social Practice. In Resnick L, 
Levine J, Teasley S (Eds.) (1991) Perspectives on Socially Shared 
Cognition . Washington, DC: APA. 1 -22. 
Richardson J (1991) Existential Epistemology: A Heideggerian Critique of the 
Cartesian Project.  Oxford: Claredon Paperbacks.  
Rilke RM (1912) Duino Elegies . Translation: Boston: Shambala. 1992.  
Rittel H (1972) Second -generation Design Methods. In Cross (1984). 3 17-327. 
Rittel H, Webber M (1973) Dilemmas in a General Theory of Planning. Policy 
Science. 4, 155-169. Alternative version as Rittel H, Webber M (1973) 
Planning Problems are Wicked Problems. In Cross (1984). 135 -144. 
Rorty R (1977) Philosophy and the Mirr or of Nature . Princeton: Princeton 
University Press.  
      Tacit and Explicit U nderstanding in Computer Support                                       318 
  Schaab B, McCall R, Schuler W (1984) Mikroplis -- ein Textbank -Management -
System. Nachrichten für Dokumentation.  35 (6). 254-259. 
Schank R (1982) Dynamic Memory . Cambridge: Cambridge University Press.  
Schön D (1983) The Reflective Practitioner . New York: Basic Books.  
Schön D (1985) The Design Studio . London: RIBA Publications.  
Schön D (1992) Designing as Reflective Conversation with the Materials of a 
Design Situation. Knowledge -Based Systems , 5, (3). 3-14. 
Schutz A (1970) Reflections on the Problem of Relevance.  New Haven: Yale 
University Press.  
Searle J (1980) Minds, Brains, and Programs. The Behavioral and Brain 
Sciences, 3. 
Searle J (1983) Intentionality: An Essay in the Philosophy of Mind . Cambridge: 
Cambridge University Press.  
Shipman F (1993) Supporting Knowledge -Base Evolution Using Multiple 
Degrees of Formality . Ph.D. dissertation. Department of Computer Science. 
University of Colorado at Boulder.  
Simon H (1973) The Structure of Ill -structured Problems.  Artificial Intelligence.  
4. 181-200. 
Simon H (1981) The Sciences of the Artificial . Cambridge: MIT Press.  
Smith, BC (19 91) The Owl and the Electric Encyclopedia. Artificial Intelligence . 
47. 251-288. 
Smolensky P, Fox B, King R, Lewis C (1987) Computer -Aided Reasoned 
Discourse, or How to Argue with a Computer. In Guindon R (Ed.) (1987) 
Cognitive Science and its Implications  for Human -Computer Interaction.  
Hillsdale, NJ: Lawrence Erlbaum.  
Snodgrass A, Coyne R (1990) Is Designing Hermeneutical? Working paper. 
Faculty of Architecture, University of Sydney.  
Stahl G (1975a) Marxian Hermeneutics and Heideggerian Social Theory: 
Interpreting and Transforming Our World.  Ph.D. dissertation. Department 
of Philosophy. Northwestern University.  
Stahl G (1975b).The Jargon of Authenticity: An Introduction to a Marxist 
Critique of Heidegger. Boundary 2 , III, (2). 489-498. 
Stahl G (1976) Attun ed to Being: Heideggerian Music in Technological Society. 
Boundary 2 , IV, (2). 637-664. 
Stahl G (1991) A Hypermedia Inference Language as an Alternative to Rule -
Based Expert Systems. Technical Report CU -CS-557-91. Computer Science 
Department, University of  Colorado at Boulder. 1 -23. 
Stahl G (1992) A Computational Medium for Supporting Interpretation in 
Design. Technical Report CU -CS-598-92. Computer Science Department, 
University of Colorado at Boulder. 1 -39. 
      Tacit and Explicit U nderstanding in Computer Support                                       319 
  Stahl G (1993a) Supporting Situated Interpretati on. Proceedings of the Cognitive 
Science Society: A Multidisciplinary Conference on Cognition.  Boulder. 
CO. June 18 -21, 1993. 965 -970. 
Stahl G (1993b) Supporting Interpretation in Design. Submitted to Journal of 
Architecture and Planning Research . Special issue on Computational 
Representations of Knowledge.  
Stahl G, McCall R, Peper, G (1992) Extending Hypermedia with an Inference 
Language: An Alternative to Rule -Based Expert Systems. Proceedings of 
the IBM ITL Conference: Expert Systems (October 19 -21, 1992). 160-167. 
Suchman L (1987) Plans and Situated Actions: The Problem of Human Machine 
Communication.  Cambridge: Cambridge University Press.  
Suchman L (1993) Response to Vera and Simon’s Situated Action: A Symbolic 
Interpretation. Cognitive Science . 17. (1). 77-86. 
Suchman L, Trigg R (1991) Understanding Practice: Video as a Medium for 
Reflection and Design. In Greenbaum & Kyng (1991). 65 -90. 
Sussman G, McDermott D (1972) From PLANNER to CONNIVER: A Genetic 
Approach . Montvale, NJ: AFIPS Press.  
Tafforin C (1990) Relationships Between Orientation, Movement and Posture in 
Weightlessness: Preliminary Ethological Observations. Acta Astronautica . 
21. 271-280. 
Toulmin S (1958) The Uses of Argument . Cambridge: Cambridge University 
Press. 
Vonnegut K (1952) Player Piano . New York: Avon.  
Vygotsky LS (1978) Mind in Society . Cambridge: Harvard University Press.  
Weizenbaum J (1976) Computer Power and Human Rea son: From Judgment to 
Calculation . New York: Freeman & Co.  
Winograd T, Flores F (1986) Understanding Computers and Cognition: A New 
Foundation for Design.  New York: Addison -Wesley. 
Winston PH (1981) Artificial Intelligence . Reading, MA: Addison -Wesley. 
Wirth N (1988) From Modula to Oberon. Software—Practice and Experience. 
18. (7). 661-670. 
Wittgenstein L (1953) Philosophical Investigations . New York: Macmillan.  
Wixon D, Holzblatt K, Knox S (1990) Contextual Design: An Emergent View of 
System Design. CHI '90 Proceedings.  
Woods WA (1975) What's in a Link: Foundations for Semantic Networks. In: 
Brachman RJ, Levesque HJ (1985) Readings in Knowledge Representation . 
San Mateo, CA: Morgan Kaufmann. 217 -242. 
 
APPENDIX  
 
 
 
A. Programming Walkthrough of the HERMES Language  
 
B. Tacit Usage of the HERMES Language  
 
C. Explicit Structure of the HERMES Language  
 
 
A. Programming Walkthrough of the 
Hermes Language  
Two programming walkthroughs (Bell, et al., 1991) were conducted of the 
HERMES language after an initial version of the language had been implemented 
and its functionality tested. The purpose of the programming walkthrough method 
is to evaluate th e "writability" of a programming language during its design phase 
by carefully considering the steps that a programmer must go through in order to 
complete a programming task in the language. In particular, note is made of the 
"doctrines" (or pieces of kno wledge) that one must have mastered in order to use 
the language. The method pinpoints factors in the design of the language that 
require large amounts of background knowledge.  
In a series of sessions during April 1992, the programming walkthrough 
methodol ogy was carefully followed for a sample task in the HERMES language. 
The language designer defined the task, briefly described the language with several 
simple examples and a copy of the BNF syntax, served as a resource about the 
language, and indicated wh ether or not progress was being made with the task. A 
professor of computer science who is particularly interested in end -user 
programming languages worked through the task. A Ph.D. student in computer 
science who had investigated the programming walkthrou gh methodology and had 
conducted many sessions with it, assisted in carrying through the programming 
walkthrough methodology.  
In August 1992, the walkthrough was repeated with a similar set of participants. 
This second walkthrough substantially confirmed the findings of the first one. For 
the sake of logical presentation, results of the two sessions will be merged together 
in the discussion here. First, the various steps in solving the task will be laid out 
and the potential problem areas that were uncover ed will be described. Then a list 
of redesign decisions will be presented, describing the rationale of the version of 
the language that emerged in response to these evaluations.  
The task.  The task for the programming walkthrough was to write a query 
statement in the language to accomplish the following: list people with four or 
more grandchildren . The participants in the first walkthrough were given a copy 
of the BNF syntax of a simplified form of the language.27 Those in the second 
 
27 A BNF of the current HERMES language can be found in Appendix C. The 
version used for the Walkthrough had a similar structure, but many of the terms 
used in that language and discussed in the present Appendix have been changed, 
      Tacit and Explicit U nderstanding in Computer Support                                       322 
  walkthrough were given a screen image of the interface to the language (similar to 
Figure 10 -3 in Chapter 10). Both groups were told that the database consisted of 
six kinds of hypertext nodes ( cats, dogs, boys, girls, men, women ) 
connected by four types of links ( parents,  owners, likes, dislikes ).  
Step 1. Construct a Query.  The language being evaluated still retained PHIDIAS' 
query language structure. It had a syntactic category named “Query” (which no 
longer exists in the revised language). Thus, the first step when work ing in the 
language used in the Walkthrough is to realize that a Query must be constructed. 
This is the first piece of doctrine about the HERMES system and its language that 
is needed to create the list of people. Non -programmers (for whom this language 
is intended) may not be familiar with the term "query" as it is used in computer 
database jargon. They might not know that queries are the mechanism to search a 
database and return a list of the items specified by the query. In practical terms, 
this issue me ans that the user of HERMES must know how to find the menu option 
for constructing a query in the HERMES language. In the walkthrough, this 
corresponds to focusing on the language options for a Query in the syntax.  
The syntax for Query is the following (Ca pitalized terms here are non -terminals 
further defined in the syntax. Note that this syntax included a number of operators 
that no longer exist in the language or that have different names as defined in 
Appendix C.):  
disclose Article Relationship Prepositi on Article Subject 
which Filter as How, with their Relationship, if Boolean, 
else Query.  
The walkthroughs emphasized several problems with this syntax. Interestingly, the 
problems pointed to were very similar in both walkthroughs, even though in the 
first sessions this syntax was displayed textually (as an explicit BNF formalism) 
and in the other session it was displayed as a dialog box with buttons for each term 
(for tacit direct manipulation). In both cases, the Query option was considered 
visually confus ing in its overall impact as well as in some of its details. Above all, 
there were simply too many terms to deal with at once.  
This complaint had several aspects. First, the number of terms was too great. It 
turned out that these terms fell into three cat egories: operative syntax options, glue 
words, and fillers. The syntax terms which represented computational mechanisms 
were the terms: Relationship, Subject, Filter, How, 
Relationship, Boolean, Query . The glue words were Article  and 
 
primarily as a result of  the Walkthrough. These changes may cause some 
confusion in reading the following discussion.  
      Tacit and Explicit U nderstanding in Computer Support                                       323 
  Preposition , which could take on values of articles and prepositions to make 
queries read more like flexible English without changing the computational 
meaning—e.g., all arguments about those answers  instead of just 
arguments of answers . The filler words were disclose, which, as, 
with their, if, else ; they make the syntax more meaningful to the human 
reader but  play no role computationally. It was felt that the word " disclose " is 
unnecessarily obscure and  might best be replaced by something like "show" or 
"list", or b e eliminated.  
The glue words seem to just get in the way. They add unnecessary work, looking 
up their possible options, and they clutter the query statement. Operator options 
like Article  and Preposition  require an extra level of look -up in addition 
to the main language syntax options. While they add a marginal degree of 
smoothness to the reading of the query, they are simply in the way during the 
writing of the query. Moreover, they obscure the functional structure of the query, 
making it difficult to det ermine what is operational in the query and what is not. 
The other filler words are less of a problem because they do not require any action 
by the query formulator and they make the structure and function of the query 
clearer even during the writing stage . Nevertheless, it was suggested during both 
walkthroughs that a radical rethinking of the language (e.g., in a LISP-style 
functional notation or in a visual programming graphical notation) might well do 
away with the fillers and lay the structure of the q uery bare. Here, the trade -off 
between supporting tacit and explicit understanding was already clearly coming 
into play.  
Given the complex definition of the query, a programmer has little guidance on 
where to begin and how to proceed. The terms in the synt ax template appear 
equally important. In fact, in this version of the language all of the terms are 
optional. Any subset of them can be defined in any order, giving the one template 
great generality and allowing it to stand for many possibilities. However,  this gives 
little guidance to the programmer. It is not clear to a novice user how the system 
would compute a Query without a Subject, or one without an if Boolean  but 
with an else Query . A more general problem is that there is little support for 
the person constructing a query step by step: where to start, what order to proceed 
in, what has been defined so far, how to test partial queries, how to re -use existing 
queries and already defined complex terms.  
Step 2. Define the Subject.  To build effective quer ies in a hypertext system like 
HERMES, one must begin by defining a Subject of the query that corresponds to 
the starting point of the search that is to be defined. For instance, in the query, 
arguments of answers , the computer will start with a set of ans wers and 
follow their argument  links to the set of their arguments, which will be the result 
      Tacit and Explicit U nderstanding in Computer Support                                       324 
  of the query. Similarly, in people that have more than 3 
grandchildren , the system will start from a set of people and traverse links to 
discover which of them hav e more than three grandchildren. However, this was 
not obvious in either walkthrough. Both attempts went astray at this initial step. In 
the April session, analysis began with the grandchildren and tried to compute their 
grandparents (eventually getting st uck trying to trace back which of the 
grandparents had more than three grandchildren). In the August walkthrough, the 
idea that the Subject of a query like arguments of answers  was answers  
seemed counter -intuitive. In fact, it seemed counter English -like. In English, "of 
answers" is a phrase modifying the noun (subject) "arguments".  
Another way of putting the problem of choosing the Subject is that the user might 
assume that the Subject is that which is to be disclosed or listed. So, in 
arguments of answers , the Subject might be taken to be the arguments that 
are sought. In fact, however, the Subject of the query must be the answers, from 
which the search for arguments begins.  
The walkthroughs fundamentally questioned the assumption that had been taken 
over from the original PHIDIAS query language that the starting point of hypertext 
navigation corresponded to what people would naturally name as the “subject” of 
a query. The strategy of the PHIDIAS language had been to model the language as 
much on the struc ture of English as possible. This strategy worked well for the 
readability of the language. However, the walkthrough began to uncover problems 
with the strategy when one wanted to write innovative expressions.  
The people who originally used the PHIDIAS query language would formulate a 
query like answers of issues with their arguments  to instruct the 
computer to start at each of the issues and then list its answers with sublists of 
all the arguments of each of those answers. It was assumed that this was the  
"English-like" phrasing, and the query language’s syntax corresponded to it nicely. 
But consider the following equally natural requests for the same output:  
* answers with their arguments of the issue.  
* for each issue list its answers and for each of the m 
list the arguments.  
* each issue's answers and their arguments.  
* arguments for each answer of the issues.  
* arguments for each issue's answers.  
It seems that any of the three operative terms can come in any position in English 
and that a variety of equa lly plausible alternatives are available for even the 
simplest queries. The users of PHIDIAS had, perhaps, been accustomed to think in 
the PHIDIAS programming language. The fact that this may have happened without 
anyone realizing that learning of a new la nguage was taking place may speak well 
      Tacit and Explicit U nderstanding in Computer Support                                       325 
  for the readability of the language, but it covered up the writability issues. The 
PHIDIAS queries seemed "English -like" not because they represented the obvious 
way to formulate the queries, but because once formulat ed their meaning 
(semantics) seemed intuitively clear. That is, a query that would procedurally 
navigate the hypertext sounded like an English language description of the results 
that would thereby be produced.  
What worked for the original PHIDIAS language cannot work for the considerably 
more complex HERMES language. The PHIDIAS language was syntactically limited 
to simple query statements. In fact, most queries formulated in practice instantiated 
a handful of patterns. Moreover, these patterns were part o f a culture existing 
among the people who worked together on PHIDIAS. The HERMES language, in 
contrast, is highly generative, allowing an unbounded variety of expression forms. 
While it is assumed that some training will be necessary for its use (in fact, 
considerably more than was given to the walkthrough participants), the language 
is supposed to be usable by designers in workplaces who have arbitrarily complex 
and innovative information retrieval needs.  
A serious confusion arose in determining the corres pondence between nodes or 
links and Subjects or Relationships. In the PHIDIAS culture, a phrase like answers 
of issues  corresponded to answer links coming out of issue nodes. The 
nodes at the other end of the answer links would, it was assumed, be answer 
nodes. In a standard PHI issue-base hierarchy this was a reasonable assumption. 
However, in the general case, a link of Type x might point to a node of Kind y. So 
the original assumptions of how node and link structu res correspond to English 
descriptions and query syntax no longer necessarily obtain.  
An issue also arose in the step of defining the Subject having to do with 
conjunctions. The Subject, people, had to be defined as a conjunction of boys, girls, 
men, and w omen. In ordinary English, one might say "men and women who ...." 
But the computer combines nodes using set operations, so one has to say, "men 
or women who .... " Whereas a native English speaker would use "men and 
women who ...." to group all the men and all the women together, the computer 
would interpret this as people who are men and who also are women, i.e., the null 
set. The first aspect of this problem is that the query writer must leave tacit 
common English and think in explicit set terms; the secon d part is that the syntax 
options redundantly included and and or along with the set operations for union 
and intersection —and the relationships among them are unspecified.  
A more general point that came up concerning the presentation of the syntax is that  
the overall structure is not clear. The syntax looks like an arbitrary listing of many 
possible syntactic templates. What are the important primitive (or first class) 
elements here and what are the rules for combining or abstracting them? If Query 
      Tacit and Explicit U nderstanding in Computer Support                                       326 
  is a primitive object, can one request: disclose queries that ... ? Are 
there general principles for combining Subject, Relationship, Filter , 
etc. that underlie the definitions of the templates? Is so, could these principles be 
given instead of the seemingly arbit rary proliferation of template options?  
Again, the question of structure goes back to the tension between the English 
language perspective and the hypertext navigation perspective. The underlying 
structure of the language as a computer programming languag e for hypertext 
querying has to do with the structure of nodes and links in the hypertext. However, 
the appearance of the language is tuned to the rather different structure of English 
language descriptions of results desired, as stated using terms of the domain 
(grandchildren , answers , wardrooms ). This tension became explicit in 
Step 3. 
The list of syntax templates arose from a series of trade -offs. The Operator options 
allowed the collapsing of several language options into one: e.g., Subject and 
Subject , Subject or Subject , ... into Subject SOperator  
Subject . This reduced the overall number of options but  added another layer of 
options (SOperator ) to go through. Another trade -off has to do with providing 
templates that correspond to common queries versus maximizing the generality of 
the options. Adding options increases the likelihood that a need can be met 
immediately without the extra effort of building up from several options or 
specializing from a complex, generalized option. The trade -off is that this  
proliferates options, making it harder to locate the correct one.  
Step 3. Think through the computation process.  At some point early in the 
formulation of a non -trivial query, one must focus on the computational process 
needed to get the desired results s tarting from the given information. For instance, 
given nodes for various kinds of people and links to parents, how can a list of 
certain grandparents be defined? In the walkthrough task, one must first generate 
a list of people by generating lists of men,  women, etc., and then combining these 
lists. Then one must perform a mapping from these people to their grandchildren 
by crossing the parent links coming into them to get to their children and then 
repeating this to get to the grandchildren. For each pers on, the number of their 
grandchildren is computed and compared to 3. Those people who do not meet this 
condition are filtered out of the list of people, and the remaining list is the desired 
output. It may be useful to conceive of the sets or lists of node s as "streams", and 
the computational process as consisting of operations on this stream such as 
generation, mapping, filtering, performing conjunctions, applying predicate tests, 
etc. (see Abelson & Sussman, 1985). Such an abstract scheme would provide a 
way of analyzing a task. If the language's syntax was organized this way, then the 
procedure of formulating a query might be more straight -forward. It is even 
      Tacit and Explicit U nderstanding in Computer Support                                       327 
  conceivable that a query formulated on the basis of this scheme could then be 
translated into an English-like format to enhance future readability.  
The point is that for any non -trivial query the writer will need to think through the 
computational process in terms of operations on nodes and links. For each 
operation, the writer will then have to selec t the proper syntax option. So the 
selection of query terms will be made on the basis of a conceptualization in terms 
of nodes and links, not directly in terms of domain concepts (answers, 
grandchildren, etc.). The domain concepts have to be translated int o system 
concepts (i.e., into the terms according to which the hypertext database is 
organized) before the structure of a query can be determined. This implies that the 
syntax should correspond to the system view which the user must develop, rather 
than to the user's native English formulation of the task.  
This consequence applies to the writing of queries, not the reading of them. If a 
query has already been stated in an English -like way so that it reads like a statement 
of the general task that it indeed carries out, then the user may not need to think in 
the system terms of nodes and links at all. This would relieve the user of a 
considerable cognitive burden and justify the approach of supporting tacit 
understanding.  
However, even if one anticipates that  the language will be used almost exclusively 
in a read mode by most users, one should not underestimate the concern for the 
language's writability. Both programming walkthroughs underlined the 
inadequacy of the "English -like" approach for programming quer ies, and the 
strongest implication of both was the necessity to redesign the syntax to reflect 
more closely a system view of computations. That is, there are important times 
when it is necessary to think in explicit computational terms and the language 
should support this as well as tacit readability.  
Step 4. Formulate the query based on the computation.  Once the necessary 
computation has been understood, the query can be formulated. A first step might 
be to consider alternative starting points for the comp utation based on the structure 
of the data. In the given task, for instance, both walkthroughs got side -tracked by 
following parent links from people to their grandparents. To complete the task, 
one must add up each person's grandchildren, which means foll owing the links in 
the other direction to each person's children and to their children, so that each 
grandparent will be associated with the set of his or her grandchildren.  
This raised a question about backwards links, called "converse" links in the syntax. 
It may not be obvious to users that links can be traversed in both directions. In fact 
in PHIDIAS they could not be. So this is intended as a new feature in HERMES, and 
the converse Relationship  option (along with its explanation in a User's 
Manual or training session) is meant to point out this possibility. In fact, the given 
      Tacit and Explicit U nderstanding in Computer Support                                       328 
  task could not be performed without the ability to traverse links in both directions. 
However, eve n if one wants to retain this functionality, "converse" may not be the 
best term to use.  
Once alternative strategies for achieving the task have been worked out, the 
programmer of the query might optionally try to estimate the relative 
computational effici ency of the alternatives. For instance, in the given task one 
might reason that only adults could have grandchildren. So, instead of starting from 
a set of people that included boys and girls, one might start from a set of people 
defined as men or women . 
The analysis of the task in terms of defined nodes and links implies the selection 
of Subjects and Relationships. These must be built from the given kinds of nodes 
and types of links, using whichever syntax templates produce the desired results 
from the pri mitives. Thus, the Subject option, Subject SOperator 
Subject  can be used to combine men and women with the appropriate 
connective selected from the list of SOperator  options. Similarly, the best Filter 
option can be chosen by a pattern matching process: the option have 
COperator Number Relationship ...  allows a numeric comparison, 
where COperator  is matched to "more than", Number to "three", and 
Relationship  to "grand children". Unfortunately, another option, have 
QOperator Relationship , also almost seems to match, necessitating extra 
analysis. 
The walkthroughs uncovered a technical problem with having the user always 
choosing from lists of defined options. For instance , to choose a primitive link type 
the user selects from a pick list containing all defined types. The advantage of this 
is that spelling mistakes are avoided, and long names can be entered with a click 
of the mouse. The problem is that the type must always  be defined before it is used. 
This creates a problem in two situations: top -down design and recursive 
definitions. Suppose one wants to define a Relationship, issues and 
discussion , before one has defined discussion . In top-down design it 
makes sense to u se a subcomponent before figuring out its definition in detail —as 
long as it gets defined before actual program execution. With the HERMES 
graphical user interface, one would at least have to define discussion  with a 
simple, nominal definition prior to ref erring to it in a higher -level definition. (Then 
one could always come back later and refine the lower -level definition.) In the case 
of recursive definitions, one could not define discussion  as: issues with 
discussion , because when one went to select the last term in this definition the 
Relationship discussion  would not yet be on the list. This is a problem arising 
from the HERMES interface. In PHIDIAS, the user simply typed any character strings 
into the command -line interface. Of course, one could work a round this problem 
      Tacit and Explicit U nderstanding in Computer Support                                       329 
  too by first defining a dummy discussion  Relationship and then redefining it 
with the recursive definition.  
Step 5. Test and refine the query.  Ideally, one should be able to build up complex 
queries iteratively, testing as one goes. This  was not possible during the 
walkthroughs because the HERMES language and its interface were not completely 
implemented. The interface should be designed to make the testing of query 
components as easy as possible.  
In addition, the construction of modular  queries should be supported. One should 
be able to define a Subject as men or women , save it with a name people and 
then subsequently use it in queries. Similarly, one should be able to define a 
Relationship converse parents of converse parents , save it w ith a 
name grandchildren , and use it later in the final Query:  
disclose people that have more than 3 grandchildren.  
This kind of modularity promotes top -down and incremental design. It also hides 
the complex details and provides building blocks for other queries in the future.  
Finally, once the task is solved and the query has been shown to work properly, 
the user may want to check the appearance of the query for readability. In the above 
example, care has been taken to name terms like people and grandchil dren 
with descriptive names in the plural, so they make sense and sound reasonable in 
the query syntax. Also note that the awkward and non -English-like phrases have 
been hidden within secondary definitions that are represented by these carefully 
chosen nam es. 
The revised language.  In response to the findings of the programming 
walkthroughs, an extensive redesign effort was undertaken. In particular, many of 
the “English -like” analogies of the original PHIDIAS query language were 
eliminated in favor of a mix ing of support for tacit and explicit understanding. The 
primary redesign decisions resulting from the walkthroughs are discussed below: 
28 
Decision 1. Provide for multiple skill levels.  The programming walkthroughs 
highlighted the problematic nature of writing expressions in the HERMES language. 
Experience using the language on more complicated tasks than that tried in the 
walkthrough suggests that, in fact, it would sometimes be easier to use a general 
 
28 It should be noted that the HERMES language continued to evolve after these 
revisions, so that the syntax in Appendix C and the examples throughout the 
dissertation do not correspond exactly to the revised version of the language 
discussed here.  
      Tacit and Explicit U nderstanding in Computer Support                                       330 
  programming language like PASCAL or LISP than to apply the HERMES language. 
This suggestion is closely related to the difference between the natural language 
model of the task and the node -and-link system model. That is, if one arranged 
programming tasks along a spectrum from trivial examples like disclose 
boys, through typical PHIDIAS queries like answers of issues with 
their arguments , to more complex computations like display people 
that have more than 3 grandchildren , and finally to small 
applications like the academic advising example (Appendix B) used to test the 
unrevised language, or to even more complex computations (like the privacy critics 
in Part III), then they would progress from being easy in PHIDIAS to being do -able 
in the HERMES language to being easier to do in a general programming language. 
The advantages of the ties of the HERMES language to natural language become 
less helpful and more of a burden the more one needs to concentrate on intricate 
computations at the node and link level.  
At the same time, an expression in the HERMES language has the great advantage 
of being very easily understood by a reader (assuming it has been carefully 
programmed with that in mind). For a design environment that is not restricted to 
use by people trained in programming, this is a great advantage. Even for trained 
programmers, use and re -use are promoted by having expressions be self -
documenting at the surface English level. Perhaps the best solution is to recognize 
that people defining complex computations will need to think explicitly in system 
terms and use programming skills, but to sh ield most users from these demands as 
much as possible. With this in mind, the HERMES language has been divided into 
a number of skill levels, defined in Chapter 10:  
* novice: read -only 
* beginner: entry and display of data trees  
* intermediate: hypertext  computations  
* advanced: multi -media critiquing  
* programmer: general programming language  
Decision 2. Replace Queries and Subjects with DataLists.  The biggest problem 
uncovered by the walkthroughs was the complexity of the syntax. This complexity 
was due primarily to two factors: the sheer number of syntactical options and the 
lack of an apparent organizing principle based on the computational structure. The 
first strategy for dealing with the complexity was to provide different levels of the 
language f or users of different skill levels. This should help users to adjust 
incrementally to the language. The second strategy is to structure the syntax more 
clearly along computational lines. This turns out to have the additional advantage 
of reducing the numbe r of options.  
      Tacit and Explicit U nderstanding in Computer Support                                       331 
  The hardest part of completing the task in the walkthroughs was the start up. This 
required the most knowledge of background doctrine. It was the most confusing; 
once one was started along the right track, the rest was much clearer. The 
determination of the computational starting point is the key —not an analysis of the 
English description of the task or of the desired results. The starting point is always 
a list of nodes (people, issues, etc.). Once this list is generated, the task is solved 
by successively performing a series of operations on this list. If one looks carefully 
at the syntax, one finds three inter -related terms for lists of nodes: Query, Subject, 
and DataList. A Query consists of the resultant list of nodes returned by a 
computation. A DataList is an arbitrary list of nodes, including Query results. A 
Subject can be a list of one node, all nodes of a certain kind, all nodes in the 
database, a DataList, a Query result (indirectly, as a DataList), or some 
combination of such lists . This is unnecessarily redundant.  
The revised language eliminates the terms Query and Subject —two terms that 
caused considerable confusion in the walkthroughs —and consolidates their 
functions under the term DataList —a term that more clearly represents a s ystem 
view of its role. The steps in solving a task are no longer to construct a "query" by 
first defining a "subject", but to compute a desired data list starting from some 
easily generated data list. The consolidation of these terms substantially lowers the 
number of options as well as clarifying their structure.  
Decision 3. Require all parameters to be defined.  Part of the confusion in 
defining Queries (and other terms) was that all their parts were optional and could 
be defined in any order. In particu lar, the main option for a Query (and hence the 
first one a user confronted) had ten terms, any combination of which could be 
defined in any order. So this first step offered the user several million permutations. 
The syntax had been structured with all te rms optional in order to make each option 
as general as possible. However, it turns out that the syntax can be defined with all 
terms required, and the result is much greater structural clarity and simplicity with 
only a few more options. Compare a slightl y cleaned up version of the old 
definition of Query (where the glue words have been eliminated and DataList  
has been used for Subjects, Queries and DataLists, for the sake of comparison) 
with part of the new definition of DataList:  
DataList ::= Association  of DataList that Filter as How, 
with their Association , if Boolean, else DataList  
DataList ::= Association of DataList | DataList that Filter 
| DataList as How | DataList with their Association | if 
Boolean then DataList , else DataList  
In the old defi nition each capitalized term is optional, in the new they are each 
required. The five options of the new definition allow one to build up a DataList 
through the same five operations that are combined in the old definition. The two 
      Tacit and Explicit U nderstanding in Computer Support                                       332 
  definitions are formally equivalent because the old one can be converted to any of 
the new options by dropping optional terms, and the new options can be nested to 
build the old definition. But look how much clearer the function of each of the new 
options is. They each define a wa y of combining a DataList with another 
syntactical term (Association , Filter, How, or Boolean ). Once one of 
the new options is chosen, there are only two choices: define the first term and then 
the second or the second and then the first. This new format makes the structure 
much clearer —for instance, it is now clear that the five operations can be 
performed in any order, whereas the older format gave the misleading and 
confusing impression that there was a required order. In fact, exactly the same 
operations are generally needed regardless of the template formats: to define 
people that have more than 3 grandchildren , one must press the 
same number of interface buttons in either version.  
Decision 4. Eliminate glue words.  The articles and prepositions have be en 
eliminated from the syntax. They may have made sense in the simple, intuitive 
days of the PHIDIAS query language, but they seemed to get in the way excessively 
in the walkthroughs. Above all, they obscured the structure of the computations 
being defined  and added to the confusing appearance of the syntax. Too much 
smoke and mirrors.  
Decision 5. Retain filler words.  The filler words ( of, that, as, with 
their, ...) have been retained in the syntax to aid in the comprehension of the 
options as well as incre asing the readability of the final expressions. " Converse " 
has been replaced by " inverse ", which is probably more colloquial. 
Disclose , which used to start all Queries, has been deleted, along with the 
troublesome terms Query and Subject . These decisions r eflect a continued 
commitment to maintaining the readability of the language. The suggested 
alternatives of a Lisp syntax or a visual programming approach are not attractive. 
Lisp requires enormous doctrinal knowledge and cognitive strain for the sake of a  
somewhat more functional notation. It is not clear that a visual programming 
approach could retain the functionality of the HERMES language syntax and still 
improve its clarity or simplicity. One could easily change the appearance of the 
options from thei r English-like format to a functional format, for instance:  
DataList ::= Association(DataList) | Filter(DataList) | 
How(DataList) | Association -sublist(DataList) | 
Boolean(DataList1, DataList2) | UnionOp(DataList1, 
DataList2)  
instead of:  
      Tacit and Explicit U nderstanding in Computer Support                                       333 
  DataList ::=  Association of DataList | DataList that Filter 
| DataList as How | DataList with their Association | if 
Boolean then DataList, else DataList  
However, for the non -programmer the filler words make the functional 
relationships much clearer.  
Decision 6. Compr ess syntax levels.  The Operator options had been created to 
consolidate options like DataList and DataList , DataList or 
DataList , etc. into DataList UnionOp DataList , where UnionOp 
::= and/or (unique sorted union) | and also 
(intersection) | but not (diffe rence) | or (append) . This 
makes sense where UnionOp  is used in several places in the syntax. However, the 
Operator options themselves proliferated, making it difficult to look them up, let 
alone remember them. In the new syntax, a number of these Operator  options have 
been combined, eliminated or moved back to the higher level options in order to 
lessen the number of steps involved. Note that the use of "and" and "or" has been 
tied to the set operations in order to clarify the sense of their computation. T he net 
result of all the changes to the syntax is a significant decrease in the number of 
options, despite an increase in the clarity of their computational structure, in their 
ease of use, and even in their functionality. Compared to the previous language , 
the revised language has only 12%, 55%, and 76% as many options in its Beginner, 
Intermediate and Advanced versions respectively.  
Decision 7. Clarify the computational structure.  The Media options of the 
revised language provide the primitive node conten ts. The Language  options are 
functions that take a DataList of nodes and return a DataList of nodes. In particular, 
DataList options generate lists (streams) of nodes. Association  options (and their 
subsets, InputAssociation  and Predicate  options) provide mappings of each input 
node to output nodes (based on navigation of links coming out of the nodes). Filter 
options are conditions applied to filter nodes out of a stream. Most of the language 
options define rules for combining options, th e majority of which are forms of 
application with different semantics, like Association  of DataList  and 
DataList with their Association  that both apply the Association to 
the DataList but return the resultant lists structured differently. In this sense, th e 
new syntax is based on a computational structure, but is displayed in an English -
like format. The English -like format is arbitrary for the writing and internal 
representation of the language (except that it may help the programmer remember 
the semantics) , and merely plays a role in the display (readability) of the language.  
Note that many options in each category are defined in terms of options from other 
categories. All options are stored in the hypermedia and can be referenced by the 
language itself (s ee the definition of ObjectType). In many ways, the revised 
      Tacit and Explicit U nderstanding in Computer Support                                       334 
  language has some of the characteristics that make LISP useful: it is functional, it 
is interpreted, and it can treat data as programs.  
Decision 8. Improve graphical computations.  The treatment of  graphics was 
sketchy and awkward in the language. For instance, to test if a chair was near a 
table, one could define a Boolean  as: ((Measure) of Graphic) is 
COperator Number , or: minimum distance to the table of the 
chair is less than 3 . In the new revis ed language, one can first define a 
measure, closest distance is less than 3 , and name that near. 
Then one can use that term in the Boolean: Graphic is Measure Graphic , 
yielding: the chair is near the table . One can then go on to define 
the kind of Boolean  required for graphical queries: most chairs are near 
at least one table . This new syntax has several advantages: users can 
define their own terms for Measures  like near, the syntax for the graphical 
Booleans  is clean, and the expression is smoothly readab le. By defining 
measures in terms of either central distance or closest distance, using the full range 
of quantity operators, and allowing quantification of both graphical terms, the 
graphical booleans provide for considerable computational flexibility.  
Decision 9. Retain safeguards against errors.  The language used scrollable pick 
lists for choosing Types, Kinds and defined terms. This protected the user from 
typing errors and from entering undefined terms, as well as reminding the user 
what terms or optio ns were available. The only keyboarding allowed was to type 
in names for new terms. This prevented a variety of kinds of user errors that would 
have required debugging —perhaps the hardest skill to require of a non -
programmer. In order to allow recursive de finitions of Associations and Input 
Associations, a recursive self  option was added to the syntax of these terms. 
Now if one defines a Relationship as issues with their recursive 
self and then names this discussion , the Relationship will automatically be 
made to read issues with their discussion . Similarly, the syntax for 
Input Associations is entirely designed to protect the user from error. Input 
Associations are intended primarily for data entry; otherwise they are just instances 
of Associations. The rea son for distinguishing them is that not all Associations 
make sense for data entry: i.e., it makes no sense to apply Filter operators to nodes 
that have not yet been input. Only those options that are meaningful for input are 
included in the syntax for Inp ut Associations and only Input Associations can be 
used by the interface mechanisms that prompt the user to elicit sequences of input.  
Decision 10. Support the construction of language expressions.  The new user 
interface to the language provides dialog bo xes in conformance with the WINDOWS 
3.1 conventions. For instance, if one wants to create a DataList, one brings up a 
dialog displaying all the syntactic options for DataLists. In a given option, each 
      Tacit and Explicit U nderstanding in Computer Support                                       335 
  term that has to be defined is represented with a butto n. Clicking the mouse on that 
button brings up a dialog with the relevant options for that term. Primitive terms 
like link Types are chosen from a pick list of defined terms. Dialogs are modal, so 
that work on a given dialog must be completed (or canceled)  before reverting to 
work on a previous stage. As an expression is built up, it is displayed at the bottom 
of the dialog box in its English -like format. Control buttons are available on most 
dialogs for naming and saving a constructed term, for bringing up  and editing a 
previously saved term, and for changing the interpretive context in which terms 
and expressions are defined. The dialog for DataLists also includes buttons for 
evaluating the DataList (testing it) and for saving the results to disk (for subs equent 
processing or viewing).  
The construction of expressions in the HERMES language could be supported with 
a wide variety of other mechanisms beyond the scope of this research. One could 
have graphical palettes of previously defined expressions, browser s of the 
hypertext structure, intelligent assistants that suggest new constructions or critique 
partial constructions, facilities for specifying desired results, checklists for steps to 
be done, and context -sensitive help. Some of these have been tried in MODIFIER 
(Girgensohn, 1992). It is hoped that defining expressions in the HERMES language 
is generally not so difficult as to warrant such extensive support. As Girgensohn 
implied, the supports he developed were largely required because of a non -intuitive 
representation of critic definitions, etc. in terms of LISP expressions and property 
sheets. Although it is likely that certain forms of support, carefully designed and 
implemented would be extremely useful, Girgensohn (1992) probably turned to 
providing s uch supports too early. The HERMES language is carefully designed to 
provide representations of useful computations for design environments that 
syntactically support designers tacit and explicit understandings.  
Decision 11. Provide training in the use and  extension of the language.  The 
walkthroughs made explicit the background doctrine that is required to write 
expressions in the HERMES language. Clearly, some instruction is needed to 
explain the purpose, format, implementation, and use of the language to new users. 
This instruction must include some discussion of navigation and computation 
across hypertext, as well as a description of the syntax, semantics, and pragmatics 
of the language itself.  
During the year since the development of the revised language, the HERMES 
language has been further refined to clarify its structure, functionality, and 
appearance. Its current design is reflected in Chapter 10 and Appendix C.  
 
 
B. Tacit Usage of the Hermes Language  
This Appendix is intended to give the flavor of the HERMES Language in use. It 
describes two small applications that were programmed during the early 
development of the language —and which actually  drove the definition of much of 
its functionality. It also discusses four computational mechanisms that can be used 
within the language. In each example application or computational technique, there 
is a mixture of support for tacit and explicit understan ding: 
* The example of family relations  shows how a system of terminology can be 
defined in the HERMES language for expressing common family relations. 
However, while these terms may be easy to use once defined, even the 
definition of a basic term like bro ther or sister ( sibling ) can require a 
relatively high degree of explicit reflection.  
* The attempt to build a mini -expert-system to automate the job of an academic  
advisor using the HERMES language was instructive. On the one hand, building 
the applicatio n strained the ability of the language to construct complex 
procedures, requiring explicit programming strategies to be applied in an 
environment whose only support for that is abstraction. On the other hand, 
once defined, the application defined a micro -world in which users could 
browse and pose queries in ways not possible in closed expert systems.  
* The definition of Predicates  as a subtle variation on Associations gives 
substantial extended power to the language in practice and at the same time 
nicely hides from the user some of the underlying complexity of definitions 
that stretch across multiple hypermedia links.  
* As programs in the language become more complex, issues of variable binding  
arise that may be confusing to think through. HERMES solves the se issues in 
an intuitive way so that they ordinarily need not come to the attention of the 
user. 
* The use of recursive procedures  to compute transitive closures —both breadth -
first and depth -first—generally requires cognitively burdensome abstract 
thinking. The HERMES language can support recursion through simple 
expressions. The problem of the recursive out is handled automatically by a 
natural convention having to do with hypermedia navigation.  
* Decision trees  can be set up using hypertext links between  nodes that contain 
conditions expressed in the HERMES language. The links between the nodes 
      Tacit and Explicit U nderstanding in Computer Support                                       337 
  model the decision tree in a clear way. This supports the explicit understanding 
of the logic of the decision tree in an intuitive manner.  
* The options of the HERMES language support defeasible reasoning  flexibly. 
They often eliminate the need to think through all the possibilities explicitly 
and allow the user to state in an understandable way the critical condition.  
Programming family relations.  A textbook example from logic programming 
like PROLOG provides a good illustration of how terms can be defined in the 
HERMES language to break down and solve a typical inference problem. The 
domain of family relations makes a nice test case because it is easy to compare the 
use of the HERMES language with one’s tacit understanding of these relations and 
with the need in ordinary conversation to occasionally make these tacit 
understandings more explicit.  
 
Figure A-1. Family relations.  
The definition of cousin from son and daughter  links. 
 
Take the problem: given a network of people nodes linked by son and 
daughter  links, infer cousin relationships. Inference is defined as the 

      Tacit and Explicit U nderstanding in Computer Support                                       338 
  combining of facts to derive new facts. In Figure A -1, facts about sons and 
daughters are combined to produce facts about who is a cousin of whom. This is a 
non-trivial task for humans, generally requiring people to consciously articulate 
part of the computation (e.g., "Let's see, her mother is my father's sister. .  . .") 
In the HERMES language, the problem can be solved by the definition of the 
following terms:  
children:  sons or daughters.  
parents:  inverse sons or inverse daughters.  
siblings:  children of parents that do not equal that (last 
subject), without duplica tes. 
cousins:  children of siblings of parents.  
Of course, these definitions require some explanations about the language —
although probably less explanation than corresponding definitions in a traditional 
programming language like LISP or PROLOG. The children predicate includes 
nodes linked by both sons and daughters  primitive links. Inverse links are 
primitive links traced backwards, like from the son back to the person whose son 
he is. The definition of siblings  is inherently tricky. Most likely, the defin er of 
this predicate would discover an adequate definition through a series of successive 
refinements. If one defines siblings  as just children of parents , one 
discovers upon first use of the predicate that the original people are always 
included among the ir own siblings, because they are sons or daughters of their own 
parents. Therefore, a condition must be added to exclude the original person (i.e., 
the last subject, to whom the expression is applied) from the result list. Similarly, 
there will usually be  duplicate names on the list of siblings because they are 
children of both the mother and the father of the original child. The simplest way 
of solving this problem while maintaining the ability to handle children of multiple 
marriages is to simply elimina te duplicates from the final list of results.  
The complexity of the definition of siblings is telling. Although the task of 
determining cousins is difficult for people, the problem does not lie in the 
definition of siblings  but rather in the sequence of st eps that must be put 
together. People naturally exclude the extra results that pop up surprisingly when 
the siblings  term is incompletely defined. This is symptomatic of the fact that 
programming in any language in any domain is going to require some expli cit steps 
of logical analysis and some efforts at debugging. No computer language can 
entirely avoid that. The primary advantage of the readability of the HERMES 
language is that once terms are successfully defined, it is clear what they mean, 
even for som eone with little training in the language. The definition of siblings is 
about as obscure as any statement in the language need be.  
Given the above definitions, the following computations can now be evaluated:  
      Tacit and Explicit U nderstanding in Computer Support                                       339 
  cousins of sandra  
people that have cousins and  have less than 3 cousins, with 
those items  
Furthermore, these definitions have begun the creation of a domain language for 
family relationships. It is an easy matter to add predicates for brothers, aunts, 
grandparents, etc.  
The academic advising applicati on. To test an early version of the HERMES 
language, an application was created using information about the curriculum of the 
College of Environmental Design at the University of Colorado. This information 
included not only lists of offered courses, but ot her facts and rules used by the 
College's official student advisor. Courses were linked to their prerequisites and to 
their categories, such as which curriculum they belonged to and which elective 
breadth requirements they satisfied. Other, less formal fac tors were also included, 
like which courses were particularly labor intensive.  
Primitive nodes and links were defined to correspond to information that students 
traditionally enter on forms prior to seeking counseling from the human academic 
advisor. This includes the student’s name, curriculum option, semester number, 
and courses taken in the past, taken currently, or proposed.  
The centerpiece of this application was the definition of a term named advice. 
The expression defining this term was built on a co mbination of several specific 
kinds of advice, which in turn used specially defined terms to compute inferences 
across the hypermedia. The idea was that a student, Sandra, could enter her name, 
curriculum option, semester number, completed courses, current  courses and 
proposed courses into the hypermedia system (instead of onto a paper form). By 
clicking on the Advice button, Sandra would initiate the query,  
advice of sandra.  
The query critiques Sandra's proposed list of courses. Figure A-2 displays a typical 
result: 
  
 
 
  Here is some advice on your choice of courses:  
 The following courses each require a lot of work. It 
would be wise not to take them in the same semester:  
   ENVD 3220 Planning Studio 2  
   MATH 1300 Calculus  
 
      Tacit and Explicit U nderstanding in Computer Support                                       340 
   The following courses are not designed for your 
curriculum option:  
   ENVD 3220 Planning Studio 2  
 
 You have not taken the listed prerequisites for the 
proposed courses:  
   ENVD 3220 Planning Studio 2  
 
 With your proposed courses you will not satisfy the 
following elective breadth requirements:  
   science 
 It would be wise to take a course in one of these areas 
rather than the following proposed courses in elective 
areas for which you have already satisfied the breadth 
requirements.  
   FINE 1012 Art History  
 
Figure A-2. Output from the academic advising application.  
 
This Figure shows the actual system output for a sample student. Computations 
have been performed to check, count, and list courses meeting or not meeting 
certain conditions. In particular, for in stance, the advice about breadth 
requirements is only displayed if the proposed courses include an elective in an 
area that has already been satisfied and do not include one in an unsatisfied area. 
This kind of inferencing facilitates the offering of impor tant information tailored 
to a particular user in a way that is impossible in a purely navigational hypermedia 
system. It begins to look like a rule -based expert system, but without many of the 
problems of such systems.  
To give a feel for the computations carried out by the language, the computation 
of prerequisite_problems  will be detailed. The query, advice of 
sandra, makes use of a term, advice. This term is defined as follows:  
advice: advice_intro and labor_intensive_advice and 
option_advice and prerequ isite_advice.  
In this way, the one term combines the terms for the four major computations in 
advice. The prerequisite_advice  component is a term defined as follows:  
prerequisite_advice: prerequisite_intro and prerequi -
site_problems if there are prerequisi te_problems.  
      Tacit and Explicit U nderstanding in Computer Support                                       341 
  This first checks to see if there are problems with prerequisites; if there are, it prints 
out a message and then lists the problem courses. The checking and listing is done 
with the following term:  
prerequisite_problems: proposed_courses that  have 
prerequisites_not_taken.  
This term checks each of the student’s proposed courses, using the following term 
: 
prerequisites_not_taken: prerequisites that are not 
included in courses_taken.  
For each of the student’s proposed courses, this term follows each prerequisite’s 
link and then checks if the node for that prerequisite is in the set of nodes resulting 
from the query, courses_taken [of sandra] . If it is not, then the proposed 
course for which it is a prerequisite is returned. An example of this was  seen in the 
advice output above, where ENVD 3220 is listed.  
Several problems can be noted in this implementation, if considered from a 
traditional computer science perspective: (i) First, there is a serious efficiency 
problem. (ii) Then, there is the comp lexity involved in setting up the application. 
(i) The efficiency problem is a result of the operator nature of the language. Many 
computations are done redundantly. For instance, in the 
prerequisite_advice  computation the term 
prerequisite_problems  is evaluated twice. Even worse, the subquery, 
courses_taken  is evaluated many times, although its result is the same each 
time for a given student. While some cases of redundancy could be eliminated with 
a more complex syntax, most are caused by the generality r equired by the design 
of the language as successive application of modularized operators and the 
conscious decision to disallow use of explicit variables in the language. The system 
is also slowed by the fact that the language is interpreted dynamically, r ather than 
being compiled. Nevertheless, the delay encountered for an application of this 
scale is scarcely noticeable —largely because the data involved is cached in RAM 
after its first access from disk, so redundant computations require no disk accesses.  
(ii) Developing an application of this level of complexity requires considerable 
system designing expertise. One needs to know how to represent the knowledge in 
hypermedia and how to build up a sequence of modular definitions. The way to 
structure a progra m in the HERMES language is to define a hierarchy of terms with 
descriptive names. In complex cases like the academic advising application, one 
must explicitly design a manageable hierarchy and choose meaningful names that 
will result in readable expressio ns. This is probably inevitable in any system. Once 
well designed, however, the system can be significantly easier to understand, 
      Tacit and Explicit U nderstanding in Computer Support                                       342 
  modify, and extend than alternative implementations would be. While the result of 
the advice term looks like the output from a  traditional expert system, the 
hypermedia flexibility is still there to explore the underlying knowledge base by 
navigation. Alternatively, one can reformulate the major query or execute a series 
of simpler queries using components of the advice predicate.  
Furthermore, the availability of all the information in hypertext makes it possible 
for users to browse the database. For instance, information could be linked to each 
course describing its content, hours, instructor, etc. The advantages of this 
approach in terms of flexibility probably outweigh the problems in settings like 
academic advising. The domain of academic advising is subject to frequent 
changes in rules and to many occurrences of “special cases” in student situations. 
Characteristics like thes e make the ability of end -users to revise and explore 
information important considerations.  
Predicates . In HERMES, the language can be integrated into the hypertext node 
and link structure in a number of ways. The first approach tried relied heavily on 
the idea of smart nodes , in which the inferencing power of the language is 
embedded in the nodes of the hypermedia. This was conceived primarily in terms 
of virtual structures , an extension of the fixed structures of textual or graphical 
nodes in traditional  hypermedia systems, suggested by Frank Halasz (1988). The 
navigational (or hypertext) approach to query evaluation was used, as found in the 
PHIDIAS query language, and the language was embedded in the hypermedia 
nodes. This was done to avoid simply gluin g together two different paradigms 
(e.g., hypermedia and PROLOG, or hypermedia and SQL, or HYPERCARD and 
HYPERTALK) and to develop the querying or inferencing capability out of the 
hypermedia paradigm itself.  
The content of a smart node is not limited to t he text or graphic originally entered 
into it. Instead the content is determined by the results of a query or conditional 
phrase associated with the node. The embedded query traverses the hypermedia 
network, so its result depends upon the current state of the network: the existence 
of other nodes, their links and their current content. When smart nodes are 
displayed, the appearance of the hyperdocument itself changes dynamically.  
Two forms of smart nodes were explored: conditional nodes  and virtual structur es. 
A conditional node contains a conditional phrase in the inference language and 
normal text or graphics. If the condition evaluates to true, the text is displayed. If 
the condition is false, nothing is displayed. For instance, in the academic advising 
application a node with the text, "Are you interested in a studio 
course?"  might have the condition, if there are courses that have 
studio_types . Then the text would be displayed only if there actually were 
studio courses for the student to choose from.  
      Tacit and Explicit U nderstanding in Computer Support                                       343 
  A virtual structure differs from a conditional node in that it contains only a query. 
Instead of fixed text, the system displays the result of the query. So, in the previous 
example, if there were studio courses and the user responded to the question with 
a "yes," then the yes response might be implemented as a link to a virtual structure 
node with the query, display all courses that have 
studio_types . The user would not see the statement of the query, just the 
results. 
Conditional nodes and virtual structures  add significant flexibility to hypermedia. 
They allow specific nodes to be responsive to changing conditions in other nodes 
of the hyperdocument. For instance, decision trees can be implemented using smart 
nodes by basing new decisions on nodes that conta in the results of previous 
decisions (see discussion of decision trees below).  
However, there is an important limitation to smart nodes. Suppose you had defined 
an inference computation for a specific node, embedded it in that node, and found 
that it worke d fine. But now you wanted to apply the same computation to other 
nodes without explicitly entering the condition or query in each of the other nodes. 
More generally, suppose you wanted to apply the computation as an operation on 
an arbitrary list of nodes . This turns out to be a critical concern because it is 
important to be able to do this within the inferencing language itself.  
Smart links—or predicates —solved the limitation of smart nodes. Predicates are 
different from primitive links or defined link t ypes. When a hypermedia system is 
designed, a set of link types is defined. For instance, in the academic advising 
application there are links of type proposed_courses  from a student's node to 
his or her chosen course nodes, and other links of type prerequisites  from 
course nodes to other course nodes. A smart link is a virtual link that is computed 
based on the definition of a term. For instance, a predicate might be defined as:  
required_prerequisites = proposed_courses that have 
prerequisites, wit h their prerequisites.  
Here, required_prerequisites  would not be a primitive defined link type, 
but a computation or an inference.  
This is an example of a query using normal primitive links:  
display the proposed_courses for sandra.  
It would be evaluated by following the proposed_courses  links from the 
student node sandra and displaying the nodes reached:  
*** PROPOSED_COURSES:  
1. ENVD 2110 Architectural Studio  
      Tacit and Explicit U nderstanding in Computer Support                                       344 
  . . . . 
This is an example of a query using smart links:  
 display the requ ired_prerequisites for sandra.  
It would be evaluated by substituting the definition for the computed link type into 
the query and displaying the result:  
***PROPOSED_COURSES:  
1. ENVD 2110 Architectural Studio  
  *** PREREQUISITES:  
  1. ENVD 1000 Environmenta l Design Studio  
  2. ENVD 1014 Intro to Environmental Design  
  . . . . 
The idea of substituting a definition for a term in a query is known as macro 
expansion . The definition of smart links as macros turns out to be an extremely 
powerful mechanism for the inferencing language. Because of the way the 
substitution is implemented, recursive definitions of smart links are possible 
(discussed below). This allows simply stated queries to evaluate tree structures and 
easily display transitive closures, in both bre adth-first and depth -first order —an 
accomplishment not matched by relational query languages like SQL.  
The HERMES language distinguishes between macros and predicates. A predicate 
is like a macro; however, when its results are displayed, they are labeled t o appear 
as though the predicate were a primitive link type. This is critical for the tacit 
understanding of the user. Now when the user says,  
display the required_prerequisites for sandra.  
the user does not need to know that required_prerequisites  is anything 
but an ordinary link type. The result is displayed without any indication of the 
internal structure, like this:  
*** REQUIRED_PREREQUISITES:  
1. ENVD 2110 Architecture Studio  
2. ENVD 1000 Environmental Design Studio  
3. ENVD 1014 Intro to Environmental Design 
. . . . 
In HERMES there are three kinds of links:  
* Primitive links, which are the traditional link types of hypermedia.  
* Macros, which add significant inferencing power by encapsulating 
computations across multiple links.  
      Tacit and Explicit U nderstanding in Computer Support                                       345 
  * Predicates, which use the power of macros but hide the complexity from the 
user.  
Predicates like required_prerequisites  had to be defined and the 
differences between types, macros, and predicates had to be explicitly considered 
during system development. However, the eventual end -user can take advantage 
of this computational power without knowing that no primitive links ac tually exist 
in the hypermedia between student nodes and their required prerequisites. The 
predicates look like simple links to the user and can be tacitly used as though they 
were simple primitive links.  
Smart links overcome the limitation of conditional nodes and virtual structures. 
Because macros and predicates are syntactically equivalent to primitive link types, 
they can be bound to arbitrary nodes or lists of nodes as if they were actual links 
coming out of those nodes. Smart links turned out to be so  powerful and flexible 
that the academic advising application was developed almost exclusively with 
them.  
Decision trees . Another important programming technique —particularly for 
expert system applications —is decision trees . A typical example of using a 
decision tree is categorization of fauna and flora. One proceeds through a sequence 
of questions posing alternative choices. Based on one’s answers, the choices lead 
down a path through the tree of decisions to the answer, e.g., the name of the animal 
or plant corresponding to the choices. Here is an example from the domain of 
academic advising, implemented with virtual structure nodes (nodes containing 
queries to be evaluated).  
Suppose we have the query, suggestion  (this query consists simply of the name 
of a node). And suppose the node named " suggestion " contains the following 
DataList: 
if envd_semester of student is less than 3 then beginner, 
else advanced.  
 Assuming that the proposition ( envd_semester of student is less 
than 3) turns out true, beginner  is evaluated. It contains the DataList,  
if there are envd_1000 that are contained in 
completed_courses of  student then completed, else 
uncompleted.  
 
      Tacit and Explicit U nderstanding in Computer Support                                       346 
   
Figure A-3. A decision tree as virtual nodes.  
The rectangles are virtual structures. Evaluating node Sugg estion produces the 
message, “Take ENVD_1000.”  
 
Suppose we take the branch of the tree (shown in Figure A -3) to the simple 
uncompleted , which contains the text, " Take ENVD 1000."  Then this text 
is displayed in response to the original query.  
The virtual s tructure nodes have implemented a decision tree in a way that is 
relatively easy to understand and to modify if necessary. The links through the 
hypermedia defined by the embedded queries reflect in a very straight -forward way 
the structure of the abstract  tree of decisions. Here again, the system requires some 
analysis to set up, but once defined in the HERMES Language it is rather self -
documenting.  
Variable binding issues.  While the above implementation of a decision tree is 
appealing, it demonstrates the  limitation of virtual structure nodes as well as their 
power. Note that in the last two queries the node student  was referred to by 
name. If one next wants to evaluate the decision tree for another student, the new 
student information must be substituted in the hypermedia network that contains 
the virtual structures. The decision tree cannot be simply applied somehow to other 
existing nodes, let alone to arbitrary lists of nodes (the way predicates can). This 
is a form of the general binding problem, a con sequence of avoiding the use of 
variables in order to keep the language easy to understand. In the HERMES 
Language one cannot say " If envd_semester of X is less than 3 ," 
except by defining a predicate to encapsulate that computation and applying the 
predicate to an arbitrary subject. That is why predicates are used so extensively in 
applications using the language.  

      Tacit and Explicit U nderstanding in Computer Support                                       347 
  However, predicates have their own binding problem . Predicates are a form of 
Association. They must ultimately be applied to (operate on) a DataList in order 
to produce a DataList result. The input DataList is referred to as the “binding 
subject.” A predicate is like a function, f(x); eventually, its parameter, x, must 
be bound to a variable value in order to be evaluated. When it is used in t he 
evaluation of a query, a predicate is implicitly (automatically) bound to whatever 
subject it is applied to. Therefore, any unbound relationship in the predicate 
definition is implicitly bound to that subject as well. However, predicates can have 
whole queries embedded in them and so a question arises concerning the subjects 
of these embedded queries. If there is an explicit subject node named in the 
embedded query, then there is no problem. However, predicates draw much of their 
power from binding to im plicit subjects, as explained in the previous paragraph. 
Therefore, the HERMES language permits leaving the subject unnamed in an 
embedded query. In such a case, the implicit subject of the embedded query is 
bound to the last explicit subject of a query (i .e., to the subject of the query in 
which the embedded query is embedded, or if that query has no explicit subject 
then the subject to which its subject is bound). This procedure is based on the usual 
assumptions of the English language, so that language e xpressions behave the way 
English-speaking users would expect them to, without the user having to think in 
programming terms.  
For an example of the two binding mechanisms presented in the previous 
paragraph, consider the problem of determining what proble ms a student has with 
missing prerequisite courses. The query for this ( prerequisite_problems 
of sandra ) can be based on a predicate named 
"prerequisite_problems " (proposed_courses that have 
prerequisites_not_taken, with their 
prerequisites_not_taken ) which contains a predicate named 
"prerequisites_not_taken " (prerequisites that do not 
include courses_taken ). 
In this query, " prerequisite_problems " is bound to the explicit subject of 
the query, sandra. The other predicate used in its definition, prerequisite s 
_not_taken , is applied to proposed_courses  through composition. So 
prerequisites  in its definition is bound to proposed_courses  (i.e., we 
are concerned with the prerequisites of the proposed courses). The issue arises with 
courses_taken . These are not co urses taken by the proposed courses, but by 
Sandra. According to the syntax of the query, courses_taken  is part of an 
embedded query: courses_taken of X . The subject is left implicit, which to 
English speakers means it refers to the previous main subject, sandra. This is in 
fact the rule used for binding implicit subjects of embedded queries in the HERMES 
Language as well.  
      Tacit and Explicit U nderstanding in Computer Support                                       348 
  The HERMES language solves the binding problem through the two mechanisms 
illustrated above. This allows predicates to exercise their po wer of leaving their 
subjects implicit, to be bound at runtime. The solution maintains the language's 
support of tacit understanding by corresponding to the intuitions of non -
programmers. While it cannot handle arcane examples requiring binding to 
multiple or obscure subjects, it handles reasonable, humanly comprehensible 
examples —including arbitrarily deep embedding of queries. The example of 
prerequisite_problems  is a realistic one, occurring in the academic 
advising application described above. The HERMES language also provides syntax 
options to specify bindings: the options that (last subject) , this 
(expression) , and those items  are part of the language’s syntax. These 
options provide an explicit choice of variable bindings, that can be left to their tac it 
defaults in many cases. These options fulfill some of the functions of variables 
using the familiar terminology of deictic reference in English.  
Recursive procedures.  Recursive programming is a potentially powerful 
technique. It is particularly useful f or processing trees of data, like family trees. In 
the academic advising application, tree structures appear in the list of course 
prerequisites. A full set of tree elements is called the transitive closure .  
A particularly interesting definition from the example domain of family relations 
is that of descendants:  
descendants:  children with their descendants  
A programmer would recognize this to be a recursive definition. That is, it not only 
lists the descendants of the starting node, but the descendants of those descendants, 
the descendants of descendants of descendants, etc. until there are no more 
generations. A non -programmer might be able to see that this definition would 
produce such a result, without having studied recursive function theory in the 
abstract. Again, the non -programmer might not be able to generate recursive 
definitions easily from scratch, yet might understand them when seen. Note that 
the recursive halt condition is implicit: stop when there are no more of the specified 
links to traverse . This is a convention that is built into the HERMES language 
implementation. It relieves the end -user from worrying about the recursive out 
condition that causes so many errors in programming languages that require its 
explicit statement.  
The two primary approaches to enumerating a transitive closure by navigation 
through a tree structure are depth-first and breadth-first. Both of these approaches 
can be programmed in the HERMES Language. The following Predicate and 
DataList definitions produce a nested, depth -first listing of the transitive closure of 
course prerequisites:  
      Tacit and Explicit U nderstanding in Computer Support                                       349 
  prerequisite_trees: prerequisites with their 
prerequisite_trees.  
ENVD_4550 and ENVD_4560 with their prerequ isite_trees.  
The following Predicate and DataList definitions produce a flat, breadth -first 
listing of course prerequisites:  
prerequisite_lists: prerequisites and prerequisite_ lists 
of them.  
prerequisite_lists of ENVD_4550, without duplicates.  
The computa tion through trees has important applications in practical problems. 
For instance, in a hypermedia design rationale system of issues, subissues of the 
issues, subissues of the subissues, etc., it is useful to define the issue_trees , a 
depth-first listing o f the whole tree of issues. If the issues can each have answers 
and arguments for the answers (as in the popular hypertext IBIS systems), then one 
wants to list deliberations —the tree of arguments on the issue tree. This is 
straight-forward to do in the la nguage. It is trickier to produce a list of the terminal 
issues, that is subissues at the leaves of the issue tree that have no subissues 
themselves. This can be done with a Predicate for terminal_issues : 
terminal_issues: if there are issues of issues then  
terminal_issues of issues, else issues.  
Defeasible reasoning . The HERMES language is also designed to take advantage 
of defeasible reasoning  in an intuitive way. Defeasible reasoning allows a system 
to be designed with certain default behavior that result s unless explicit action is 
taken to change it. Suppose in a hypertext network of issues and answers one wants 
to allow a user to accept, reject, or ignore answers by attaching status links to 
nodes containing words like "accept", "reject", "ignore", "don' t care", or no links. 
One might also want to allow multiple status links from any given answer node. 
So there may be contradictory information attached to an answer, or no information 
at all. Suppose further that one wants to display an_important_issue  unless 
all its answers have been explicitly rejected with status links to "reject". This 
would require defeasible reasoning, a very robust approach. The following query 
could be used:  
if there are not answers of an_important_issue that have 
no statuses that c ontain "reject" then 
an_important_issue, else rejection_message  
This query has to do with the resolution of answers to issues in the issue -base. This 
is a critical task for use of a PHI issue-base, yet it has not been supported in design 
environments like JANUS and PHIDIAS in the past. If issues are explicitly resolved 
by, for instance attaching status links, then related functions within a design 
      Tacit and Explicit U nderstanding in Computer Support                                       350 
  environment like the display of palette items can respond to these decisions with 
expressions like the precedin g query. 
Note that defeasible reasoning allows one to ignore all the possible combinations 
of potentially redundant or contradictory conditions (e.g., multiple status links 
from a given node) and express just the desired condition. This is supported by the  
Quantifiers in the HERMES language, such as all, most, no, the only 
one, at least one,  etc. The end -user can formulate an expression based 
on a tacit understanding; the explicit computations are left to the implementation 
of the language.  
 
C. Explicit Structure of the HERMES  Language  
Syntax of the HERMES language . This is a complete listing of the options of the 
HERMES language in BNF format. This is the full advanced version of the 
language, incorporating all the option s for the beginner and intermediate levels as 
described in Chapter 10. All Capitalized Terms are non -terminals. Underlined 
terms are literal terminals. (Words in parentheses) are comments. Other terms 
describe terminals. [Terms in square brackets] are opti onal. The start symbol is 
DataList. 
 
-------------- language elements ----------------------------------------  
 
DataList ::=   SimpleDataList | ComputedDataList  
SimpleDataList  ::=   a node name | id: an object id | Character 
| Number | Boolean | NodeKind | LanguageType | items | that (last 
subject) | this (expression ) | those items | contents of ResultList | a 
DataList name  
ComputedDataList  ::=  DataList Combination DataList | 
Association of DataList | DataList with their Association | 
DataList that Filter | Graphic [ immediately ] in Graphic | DataList 
in context Context | either DataList or DataList | if Boolean then 
DataList [, else DataList] | DataList, sorted | DataList, without 
duplicates  
 
Association ::=  SimpleAssociation | InputAssociation | 
ComputedAssociation | Predicate  
SimpleAssociation  ::=  LinkType | name | id | creation date | creator | last 
modification date  | contexts | all associations  | [immediate]  parts | 
Dimension | Distance in Units from Graphic [ in Graphic] | an 
Association name  
Predicate  ::=    Association  
InputAssociation  ::=  LinkType | InputAssociation with their 
InputAssociation | InputAssociation and InputAssociation | an 
input association name  
      Tacit and Explicit U nderstanding in Computer Support                                       352 
  ComputedAssociation  ::=  Association of Association | Association 
with their Association | Association that Filter | inverse 
Association | either Association or Association | if Boolean then 
Association [, else Association] | Association Combination 
Association | the Number th Association | Association, sorted | 
Association, without duplicates  
 
Filter ::=  SimpleFilter | CharacterFilter | NumberFilter | 
BooleanFilter | ContextFilter | GraphicFilter | 
ComputedFilter  
SimpleFilter  ::=   equal DataList | named Character | 
included in DataList | include DataList | of kind NodeKind | of 
type LanguageType | a Filter name  
CharacterFilter  ::=   include Character  
NumberFilter  ::=   Counter 
BooleanFilter  ::=   true 
ContextFilter  ::=   view [Counter] DataList | inherit from 
Context | are inherited by Context 
GraphicFilter  ::=   [immediately]  contain Graphic | 
[immediately]  contained  in Graphic | Measure [Quantifier] 
Graphic [ in Graphic] | have Attribute is Value | have Attribute is 
Number 
ComputedFilter  ::=   have Counter Association [ with those 
items] | have Quantifier Association that Filter [with those items] 
| if Boolean then Filter [else Filter] | Filter Connective Filter | are 
Filter | are not Filter | do not Filter 
 
--------------- media elements ----------------------------------------------  
 
Character  ::=  SimpleCharacter | ComputedCharacter  
SimpleCharacter  ::=   character string | a Character name  
ComputedCharacter  ::=  substring of Character from Number for 
Number | Character append Character  
 
      Tacit and Explicit U nderstanding in Computer Support                                       353 
  Number ::=  SimpleNumber | ComputedNumber  
SimpleNumber  ::=   real number | a Number name  
ComputedNumber  ::=  count of DataList | minimum  DataList | maximum  
DataList | total of DataList | product of DataList | Number + 
Number | Number - Number | - Number | Number x Number | 
Number / Number | list of Distance in Units among Graphic, 
Graphic[, Graphic] [ in Graphic]  
 
Boolean ::=   SimpleBoolean | ComputedBoolean  
SimpleBoolean  ::=   true | false | a Boolean name  
ComputedBoolean  ::= there are Counter DataList | Quantifier DataList 
Filter | not Boolean | Boolean Connective Boolean | Graphic 
Measure [Quantifier] Graphic [ in Graphic] 
 
Graphic ::=  SimpleGraphic | ComputedGraphic  
SimpleGraphic  ::=   polyline | a Graphic name  
ComputedGraphic  ::=  DataList ( of type graphic) 
 
Image ::=  bitmap image | an Image name  
 
Pen ::=  pen sketch | a Pen name  
 
Sound ::=  sound segment | a Sound name  
 
Video ::=  video segment | a Video name  
 
Animation  ::=  animation segment | an  Animation name  
 
ComputedView  ::=  DataList arranged in a window | a ComputedView name  
 
      Tacit and Explicit U nderstanding in Computer Support                                       354 
  ------------------- network elements -----------------------------------------  
 
NodeKind  ::=  a NodeKind name  
 
LinkType  ::=  a LinkType name  
 
Context ::=  a Context name   
 
ResultList  ::= name of an evaluated DataList  
 
------------------ namable terminology elements -----------------------------  
 
Counter ::=  (at least one) | more than Number | less than Number | 
exact Number | not Counter | Counter Connective Counter 
| a Counter name  
 
Quantifier  ::=  no | any | all | most | the (only one) | Counter | a Quantifier 
name 
 
Measure  ::=  Distance is Counter Units | not Measure | Measure 
Connective Measure | a Measure name  
 
------------------ simple terminology elements ----------------------------------------  
 
Connective  ::=  and (logical) | or (logical)  
 
Combination  ::=  and (unique sorted union) | and also (intersection ) | but not 
(difference ) | or (append) | with (and, indented)  
 
      Tacit and Explicit U nderstanding in Computer Support                                       355 
  Distance ::=  central distance | closest distance | x distance | y distance 
| z distance  
 
Units ::= inches | feet | cm | meters  
 
Dimension  ::=  length | area | volume | x width | y height | z depth  
 
Attribute  ::=  font | color | pen width | brush style | brush width | . . . .  
 
Value ::=  roman | helvetica | red | blue | striped | plaid | . . . .  
 
LanguageType  ::=  data lists | associations | filters | characters | numbers | 
booleans | graphics | images | pens | sounds | videos | 
animations | computed views | node kinds | link types | 
result lists | contexts | counters | quantifiers | measures  
 
Denotational semantics of the H ERMES language. The semantics of the HERMES 
Language wa s formalized using the notation of Schmidt (1986), based on the 
denotational semantics of Strachey and Scott. The abstract syntax, semantic 
algebras, and valuation functions provide a formal specification for the HERMES 
source code implementation. Each opt ion in the abstract syntax is programmed as 
an object. The semantic algebras are implemented by these objects, which are 
given methods corresponding to the operations specified for the algebras. 
Evaluation methods for the objects correspond very closely to  the valuation 
functions specified for the syntactic options. In addition, each object has methods 
for displaying itself and each object can be given a name by the user when it is 
defined. 
For instance, a typical option in the syntax, DataList ::= Associat ion 
of DataList , might be programmed as follows in object -oriented Pascal:  
 
DataListAofD := object(DataList)  
 function Eval(InList: DataListPtr): DataListPtr; virtual;  
 procedure Display; virtual;  
private 
      Tacit and Explicit U nderstanding in Computer Support                                       356 
   TheAssociation : AssociationPtr;  
 TheDataList : DataListPtr;  
end; 
 
function DataListAofD.Eval(InList: DataListPtr): 
DataListPtr;  
begin 
 Eval := TheAssociation^.Eval(TheDataList^.Eval(nil));  
end; 
 
procedure DataListAofD.Display;  
begin 
 TheAssociation^.Display;  
 write(' of ');  
 TheDataList^. Display;  
 writeln;  
end; 
This defines the Association of DataList  option as an object that inherits 
from the DataList object, has data items corresponding to its constituent 
Association and DataList , and has methods for displaying and evaluating 
itself. Not e how the Eval method follows the same applicative process as the 
valuation function from the denotational semantics:  
 D[[A of D]] = d. z. A[[A]] ( D[[D]] z 
 ) 
First it evaluates D, the DataList,  (using the h ypertext database z, but ignoring 
the input DataList d) and then applies the evaluation of A, the Association, 
to this intermediate result. (The notation A[[A]] means the Association valuation 
of A, that is the evaluation of a given Association instance in  accordance with 
whichever option of the Association syntax it instantiates.) The Display method 
similarly displays the Association  using whatever method corresponds to the 
particular Association instance, displays the character string ' of ', and then dis plays 
the DataList  with the method appropriate to its instance. This approach to 
polymorphic execution depending upon the particular form of the instances at 
runtime provides the flexibility to define methods that handle nesting of phrases. 
In other words,  Association  can take the form of any Association option and 
DataList  can take the form of any DataList option. This allows the HERMES 
Language to have the kind of phrase structure that English has, with arbitrarily 
deep nesting of phrases.  
The denotationa l semantics of the HERMES language is extraordinarily simple 
because the language has been designed to minimize the amount of programming 
      Tacit and Explicit U nderstanding in Computer Support                                       357 
  doctrine required. In particular, there is no state change and no continuation 
processing because there are no assignm ent statements and no explicit iteration 
constructs. In fact, there is no store because there are no variables.29 Moreover, 
there is no explicit typing. This all makes for a simple, straight -forward language 
structure.  
Balancing the structural simplicity of the language is the wealth of individual 
syntax options. The quantity of options results from the history of design trade -
offs detailed in Appendix B. In particular, there was a concerted effort to provide 
a broad range of useful functionality while res tricting the possibilities for creating 
problematic constructs. There are over a hundred options for the Advanced 
Version of the HERMES Language. Most of them define permissible and useful 
combinations of other options and are relatively self -explanatory. A few of them 
require more explanation.  
 
Informal semantics of the H ERMES language.  
In the following, the major options listed in the syntax above are explained briefly 
and examples of their use is given.  
Simple DataLists . These generate ordered lists of nodes from the database. Most 
of the Simple options generate a list of one node. The options for DataLists signify 
that these lists of nodes can be generated in the following ways:  
By specifying the name of a node. Names are optional for nodes. For example : 
archie’s lunar habitat  
By giving the Id of a node. All nodes have unique numeric identifiers that are used 
internally by the HERMES system. 
id: 2345  
By defining a Character node using any of the Character options.  
substring of privacy message from 1 to 26 
By defining a Number node using any of the Number options.  
 
29 In fact, there is a very limited state cha nge, implemented with a specific 
associated store for the DataList options that (last subject), this 
(expression), and those items . The first two of these each require a 
special stack and the third requires a list to keep track of their changing values. 
These are simple to implement and can be easily accounted for in the denotational 
semantics without all the overhead of variable names and assignments.  
      Tacit and Explicit U nderstanding in Computer Support                                       358 
  47 
By defining a Boolean node using any of the Boolean options.  
there are more than 3 grandchildren of sandra  
All nodes in the database of a specified NodeKind  
lunar habitats  
All nodes in the da tabase of a specified LanguageType  
datalists that have authors that contain "Sandra"  
All nodes in the database  
items 
that (last subject)  stands for whatever the last explicitly specified 
subject was during evaluation. This is used in the definition of pred icates, 
where it is not known what will be operated on by an expression  
parts of inverse parts that do not equal that (last subject)  
this (expression)  means the item currently being operated upon. This is 
similar to a reference to “self” in other languages  
issue_trees: issues with their this (expression)  
those items  refers to the last list of intermediate result items computed. This 
option saves intermediate results so they do not have to be recalculated in order 
to be displayed  
prerequisite_trees: prerequi sites and prerequisite _trees 
of those items  
prerequisites and this (expression) of those items  
The name of a stored DataList whose contents (not definition) is to be used  
contents of archie’s problem areas  
The name of a defined ResultList whose definitio n (not stored contents) is to be 
evaluated  
sandra’s prerequisite problems  
Computed DataLists . These generate ordered lists of nodes from the database. 
Most of these apply one operator to another to generate a DataList:  
By combining two DataLists with a Com bination 
      Tacit and Explicit U nderstanding in Computer Support                                       359 
  men and women  
By applying an Association to an existing DataList (and traversing links to arrive 
at a new list).  
answers of the privacy issue  
By applying an Association to an existing DataList and listing the DataList with 
the Associations of each item listed under that item and indented. The term 
“with” indicates that indenting will take place for the results of the 
Association. Note that the Association operator is applied to the DataList 
results. 
answers of the privacy issue with their arguments  
By applying a Filter to an existing DataList (and eliminating nodes which do not 
pass through).  
chairs that are near tables  
By specifying a Graphic that is internal to a hierarchical Graphic. If the optional 
term “immediately” is used,  then only the first level parts of the Graphic will 
result, and not the parts of parts, etc. as when the “immediately” keyword is 
absent. 
chairs in (graphic) habitats  
areas immediately in (graphic) habitats  
By selecting a DataList as viewed within a conte xt other than the currently active 
perspective  
habitats in context lunar gravity  
By choosing between two existing DataLists depending upon whether the first has 
any items when evaluated  
either problem areas or approval message  
By evaluating a Boolean and c hoosing between two existing DataLists; the second 
DataList is optional.  
if stove is near curtains then flammability issue, else 
default_critic  
By sorting a DataList  
men and women, sorted  
By removing duplicates from a DataList  
      Tacit and Explicit U nderstanding in Computer Support                                       360 
  men and boys, without dupli cates 
Simple Associations.  These are computations that map or transform one list of 
nodes into another, based on the links coming into or out of the nodes in the first 
list. The transformations can take place as follows:  
All links of a specified Link Type  
sons  
The name of a node. This is a pseudo -Association that allows internally stored 
names to be referenced in the HERMES language 
name of sons of sandra  
The id of a node. This is a pseudo -Association that allows internally stored ids to 
be referenced in t he HERMES language 
id of sandra  
The creation date of a node. This is a pseudo -Association that allows internally 
stored names to be referenced in the HERMES language. Design environments 
built on HERMES could make timestamping automatic  
creation date of ar guments of answers of an interesting 
issue 
The creator of a node. This is a pseudo -Association that allows internally stored 
names to be referenced in the HERMES language. Design environments built 
on HERMES could automatically stamp a newly created node with the user’s 
login name  
creator of an int eresting issue  
The last modification date of a node. This is a pseudo -Association that allows 
internally stored names to be referenced in the HERMES language. Design 
environments built on HERMES could make timestamping automatic  
last modification date of a rguments of answers of an 
interesting issue  
List the contexts in which something is defined. This is a pseudo -Association.  
contexts that inherit from archie’s perspective  
List every association  
all associations of the privacy issue  
      Tacit and Explicit U nderstanding in Computer Support                                       361 
  Parts of a graphical hie rarchy. If the optional term “immediate” is used, then only 
the first level parts will result, and not the parts of parts, etc. as when the 
“immediate” keyword is absent.  
immediate parts of archie’s habitat  
parts of archie’s habitat  
Any Dimension (see Di mensions below). This is a pseudo -Association  
length of subparts of archie’s habitat  
Distance from a specified graphical object. When applied to one or more graphical 
objects, this returns the numeric distance(s). Distances are always measured 
within some implicitly or explicitly specified encompassing graphic  
closest distance in feet from table in archie’s habitat  
The name of a defined Association  
sons  
Predicates.  These are Computed Associations that display their resultant lists 
differently in order to h ide the computations that have been encapsulated in the 
Predicate definition. Any Association definition can optionally be stored as a 
Predicate. For instance, the Association  
discussion: issues with their answers with their arguments  
can be stored as an A ssociation or as a Predicate. The same nodes would appear in 
the lists generated by the use of either, but the lists would appear differently when 
displayed. The results of the Association would be labeled as issues, 
answers,  and arguments , and they would be indented accordingly to show 
the structure of the computation. The results of the Predicate, in contrast, would all 
be labeled discussion  and would not be indented. To the user, it would appear 
that the results of the Predicate were all linked directly to the original nodes by 
simple links of type discussion —so the complexity of the actual computation 
would be hidden.  
 InputAssociation.  This is a subclass of Associations that is used for formulating 
macros for input of structured data. Its definitions ar e identical to the 
corresponding Association definitions, but they are limited as to the complexity of 
their structure. In particular, they are limited to forms meaningful for prompting 
input of new nodes. Any InputAssociation  can be included wherever a As sociation 
can be used, and it can be saved as an Association or a Predicate. However, the 
reverse is not true, and only expressions saved as InputAssociation  can be used for 
eliciting the entry of new nodes. For instance, if discussion  were saved as an 
      Tacit and Explicit U nderstanding in Computer Support                                       362 
  InputAssociation, then the user could be prompted to enter a hierarchy of design 
rationale automatically. First, the system would prompt for an issue. For each issue 
entered, it would prompt for a series of answers. And as each answer was entered, 
the user wo uld be prompted for arguments to support it.  
Computed Association.  These combine Simple Associations with other 
operations.  
Apply one Association to the result of another Association  
arguments of answers  
Apply one Association to the result of another Asso ciation and list each item of 
the result of the first Association with its Associations listed under it and 
indented 
answers with their arguments  
First apply an Association and then apply a Filter  
 sons that are contained in siblings of sandra  
Follow the in-coming Association links instead of the usual out -going links  
inverse parent  
Choose between two existing Association results depending upon whether the first 
has any items when evaluated  
either sons or daughters  
Evaluate a Boolean and choose between  two existing Associations; the second 
DataList is optional.  
if stove is near curtains then arguments  
Combine two Associations with a Combination  
sons and daughters  
Select the n -th Association  
the 7th son  
Sort the Association results  
authors of novels, so rted 
Remove duplicates from the Association results  
authors of novels, without duplicates  
      Tacit and Explicit U nderstanding in Computer Support                                       363 
  Simple Filters . Filters are conditional operators applied to each node in a DataList; 
if the condition is true of the node, then the node is retained (from the input  list, in 
the output list). The following filtering operations are defined:  
Check if an item is equal to (the same object as) an item specified by a DataList  
habitats that have chairs that equal archie’s favorite 
chair 
Check if an item has a name specified  by a defined Character  
habitats that are named the secret word  
Check if an item is included in a defined DataList  
chairs that are included in habitats  
Check if an item includes a defined DataList  
habitats that include chairs  
Check if an item is of a ki nd defined by a NodeKind  
parts of habitats that are of kind chair  
Check if an item is of a type defined by a LanguageType  
items that are of type distances  
The name of a defined Filter  
are desirable  
Multimedia Filters . These include filters specific to Characters, Numbers, 
Booleans, Contexts, and Graphics.  
Check if a substring is included that is defined by a Character  
messages that include the warning string  
Check if a numeric item equals an amount that is defined by a Count  
that are more th an 3 
Check if a boolean value equals true  
test conditionals that are true  
Check if a specified DataList or Count of the DataList can be viewed in a Context  
contexts that view more than 7 issues that include “bunk”  
      Tacit and Explicit U nderstanding in Computer Support                                       364 
  Check if a Context inherits from another C ontext 
contexts that inherit from archie’s context  
Check if a Context is inherited by another Context  
contexts that are inherited by archie’s context  
Check if a graphical item contains the graphical items that are defined by a 
DataList. The keyword “immedi ately” restricts the computation to the highest 
level parts.  
habitats that contain chairs  
Check if a graphical item is contained in the graphical items that are defined by a 
DataList. The keyword “immediately” restricts the computation to the highest 
level parts. 
chairs that are immediately contained in habitats  
Check if graphical items are a distance defined by a Measure from items defined 
by a DataList. This may optionally be quantified with a Quantifier. Distances 
are implicitly or explicitly measured w ithin a Graphic  
that are near most stoves in the kitchen  
Check if an Attribute value equals Value  
that have color is red  
Check if an Attribute value equals Number  
that have pen width is 5  
Computed Filters . These include Filters that combine other operators . 
Check if there are a certain number defined by Count of Associations. Optionally 
sublist the intermediate results  
that have more then 3 grandchildren with those items  
Check if there are a certain number defined by Quantifier of Associations that pass 
a Filter. Optionally sublist the intermediate results  
that have all grandchildren that are of kind boy  
Check a Filter only if a Boolean is true. Optionally check an alternative Filter 
otherwise  
that if test conditional then are  red, else are blue  
      Tacit and Explicit U nderstanding in Computer Support                                       365 
  Check if items pass both of (or one of) two Filters, depending on the Connective, 
logical and/or  
that are more than 3 and (logical) are less than 7  
Check if items do or do not pass a Filter  
that are equal “bunk”  
that are not named “my bunk” 
that do not equal “bunk”  
 
The semantics of the remaining media options, network options, namable 
terminology, and simple terminology options are straight -forward and should be 
clear from their BNF syntax. The media elements  provide the primitive valu es for 
the content of nodes and the terminal values for the language options. However, 
they also include computations involving other object types. The network 
elements  define the graph structure of the database. Some node kinds and link 
types have been pr e-defined for internal use by the system. They are available to 
the user, but cannot be modified. The namable terminology elements  serve 
mainly to provide choices for the language options. However, they can involve 
computations. Just like any of the above options, these can be named and saved. 
For example, some and several  have already been defined in the HERMES seed 
as supplementary Quantifiers this way. It has been assumed in the examples above 
that several Measures have been defined, like too near or far away from . 
These can be redefined and personalized by users in their interpretive perspectives. 
In contrast, the simple terminology elements  are fixed: they cannot be named or 
redefined and extended by users.  
 
  
      Tacit and Explicit U nderstanding in Computer Support                                       366 
   
 
 
 
 
                  
 
 
 
 
 
 
 
 
 
 
 
 
 
 

